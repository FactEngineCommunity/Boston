// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void Parseddl(ParseNode parent) // NonTerminalSymbol: ddl
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ddl), "ddl");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.CREATE); // ZeroOrMore Rule
            while (tok.Type == TokenType.CREATE)
            {

                 // Concat Rule
4ParsecreateTableStatement(node); // NonTerminal Rule: createTableStatement

                 // Concat Rule
4tok = scanner.Scan(TokenType.SEMICOLON); // Terminal Rule: SEMICOLON
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SEMICOLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.CREATE); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ddl

        private void ParsecreateTableStatement(ParseNode parent) // NonTerminalSymbol: createTableStatement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.createTableStatement), "createTableStatement");
            parent.Nodes.Add(node);


             // Concat Rule
3tok = scanner.Scan(TokenType.CREATE); // Terminal Rule: CREATE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CREATE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CREATE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.TABLE); // Terminal Rule: TABLE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.LPAREN); // Terminal Rule: LPAREN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.PRIMARY); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.IDENTIFIER:
5ParsecolumnDefinitionList(node); // NonTerminal Rule: columnDefinitionList
                    break;
                case TokenType.PRIMARY:
5ParseprimaryKeyConstraint(node); // NonTerminal Rule: primaryKeyConstraint
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

             // Concat Rule
3tok = scanner.Scan(TokenType.RPAREN); // Terminal Rule: RPAREN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: createTableStatement

        private void ParsecolumnDefinitionList(ParseNode parent) // NonTerminalSymbol: columnDefinitionList
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.columnDefinitionList), "columnDefinitionList");
            parent.Nodes.Add(node);


             // Concat Rule
3ParsecolumnDefinition(node); // NonTerminal Rule: columnDefinition

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
4tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
4ParsecolumnDefinition(node); // NonTerminal Rule: columnDefinition
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: columnDefinitionList

        private void ParsecolumnDefinition(ParseNode parent) // NonTerminalSymbol: columnDefinition
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.columnDefinition), "columnDefinition");
            parent.Nodes.Add(node);


             // Concat Rule
3tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3ParsedataType(node); // NonTerminal Rule: dataType

             // Concat Rule
            tok = scanner.LookAhead(TokenType.CONSTRAINT, TokenType.REFERENCES); // Option Rule
            if (tok.Type == TokenType.CONSTRAINT
                || tok.Type == TokenType.REFERENCES)
            {
4ParseconstraintList(node); // NonTerminal Rule: constraintList
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: columnDefinition

        private void ParsedataType(ParseNode parent) // NonTerminalSymbol: dataType
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.dataType), "dataType");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.TEXT, TokenType.DATETIME); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.NUMBER:
5tok = scanner.Scan(TokenType.NUMBER); // Terminal Rule: NUMBER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.TEXT:
5tok = scanner.Scan(TokenType.TEXT); // Terminal Rule: TEXT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TEXT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TEXT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DATETIME:
5tok = scanner.Scan(TokenType.DATETIME); // Terminal Rule: DATETIME
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DATETIME) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DATETIME.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: dataType

        private void ParseconstraintList(ParseNode parent) // NonTerminalSymbol: constraintList
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.constraintList), "constraintList");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.CONSTRAINT, TokenType.REFERENCES); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.CONSTRAINT:

                     // Concat Rule
5tok = scanner.Scan(TokenType.CONSTRAINT); // Terminal Rule: CONSTRAINT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CONSTRAINT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CONSTRAINT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
5tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
5ParseprimaryKeyConstraint(node); // NonTerminal Rule: primaryKeyConstraint
                    break;
                case TokenType.REFERENCES:
5ParseforeignKeyConstraint(node); // NonTerminal Rule: foreignKeyConstraint
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: constraintList

        private void ParseprimaryKeyConstraint(ParseNode parent) // NonTerminalSymbol: primaryKeyConstraint
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.primaryKeyConstraint), "primaryKeyConstraint");
            parent.Nodes.Add(node);


             // Concat Rule
3tok = scanner.Scan(TokenType.PRIMARY); // Terminal Rule: PRIMARY
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRIMARY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRIMARY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.KEY); // Terminal Rule: KEY
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.KEY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.LPAREN); // Terminal Rule: LPAREN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3ParseprimaryKeyColumnList(node); // NonTerminal Rule: primaryKeyColumnList

             // Concat Rule
3tok = scanner.Scan(TokenType.RPAREN); // Terminal Rule: RPAREN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: primaryKeyConstraint

        private void ParseprimaryKeyColumnList(ParseNode parent) // NonTerminalSymbol: primaryKeyColumnList
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.primaryKeyColumnList), "primaryKeyColumnList");
            parent.Nodes.Add(node);


             // Concat Rule
3tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
4tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
4tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: primaryKeyColumnList

        private void ParseforeignKeyConstraint(ParseNode parent) // NonTerminalSymbol: foreignKeyConstraint
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.foreignKeyConstraint), "foreignKeyConstraint");
            parent.Nodes.Add(node);


             // Concat Rule
3tok = scanner.Scan(TokenType.REFERENCES); // Terminal Rule: REFERENCES
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REFERENCES) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REFERENCES.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3tok = scanner.Scan(TokenType.LPAREN); // Terminal Rule: LPAREN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
3ParseforeignKeyColumnList(node); // NonTerminal Rule: foreignKeyColumnList

             // Concat Rule
3tok = scanner.Scan(TokenType.RPAREN); // Terminal Rule: RPAREN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: foreignKeyConstraint

        private void ParseforeignKeyColumnList(ParseNode parent) // NonTerminalSymbol: foreignKeyColumnList
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.foreignKeyColumnList), "foreignKeyColumnList");
            parent.Nodes.Add(node);


             // Concat Rule
3tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
4tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
4tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: foreignKeyColumnList

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.CREATE, TokenType.EOF); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.CREATE:
5Parseddl(node); // NonTerminal Rule: ddl
                    break;
                case TokenType.EOF:
5tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.EOF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start


    }

    #endregion Parser
}
