' Generated by TinyPG v1.3 available at www.codeproject.com

Imports System
Imports System.Collections.Generic


Namespace TinyPG
#Region "Parser"

    Partial Public Class Parser 
        Private m_scanner As Scanner
        Private m_tree As ParseTree

        Public Sub New(ByVal scanner As Scanner)
            m_scanner = scanner
        End Sub


    Public Function Parse(ByVal input As String) As ParseTree
            m_tree = New ParseTree()
            Return Parse(input, m_tree)
        End Function

        Public Function Parse(ByVal input As String, ByVal tree As ParseTree) As ParseTree
            m_scanner.Init(input)

            m_tree = tree
            ParseStart(m_tree)
            m_tree.Skipped = m_scanner.Skipped

            Return m_tree
        End Function

        Private Sub ParseFACTREADING(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTREADING
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTREADING), "FACTREADING")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.FRONTREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.FRONTREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.FRONTREADINGTEXT) ' Terminal Rule: FRONTREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.FRONTREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FRONTREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FRONTREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FRONTREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FRONTREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME

                 ' Concat Rule
                ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATEPART, TokenType.FOLLOWINGREADINGTEXT) ' Option Rule
                If tok.Type = TokenType.PREDICATEPART Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Then
                    tok = m_scanner.LookAhead(TokenType.PREDICATEPART, TokenType.FOLLOWINGREADINGTEXT) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.PREDICATEPART
                            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.FOLLOWINGREADINGTEXT
                            tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATEPART"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Else
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATEPART"))
                End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTREADING

        Private Sub ParseMODELELEMENT(ByVal parent As ParseNode) ' NonTerminalSymbol: MODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENT), "MODELELEMENT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.PREBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.PREBOUNDREADINGTEXT) ' Terminal Rule: PREBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.POSTBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.POSTBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.POSTBOUNDREADINGTEXT) ' Terminal Rule: POSTBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.POSTBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MODELELEMENT

        Private Sub ParsePREDICATECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: PREDICATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PREDICATECLAUSE), "PREDICATECLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.PREDICATEPART) ' Terminal Rule: PREDICATEPART
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.PREDICATEPART Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATEPART"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATEPART) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATEPART
                tok = m_scanner.Scan(TokenType.PREDICATEPART) ' Terminal Rule: PREDICATEPART
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREDICATEPART Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATEPART"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATEPART) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: PREDICATECLAUSE

        Private Sub ParseStart(ByVal parent As ParseNode) ' NonTerminalSymbol: Start
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.Start), "Start")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseFACTREADING(node) ' NonTerminal Rule: FACTREADING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: Start


    End Class
#End Region
End Namespace

