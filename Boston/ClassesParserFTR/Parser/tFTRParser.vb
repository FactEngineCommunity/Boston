' Generated by TinyPG v1.3 available at www.codeproject.com

Imports System
Imports System.Collections.Generic


Namespace FTR
#Region "Parser"

    Partial Public Class Parser 
        Private m_scanner As Scanner
        Private m_tree As ParseTree

        Public Sub New(ByRef scanner As Scanner)
            m_scanner = scanner
        End Sub


    Public Function Parse(ByVal input As String) As ParseTree
            m_tree = New ParseTree()
            Return Parse(input, m_tree)
        End Function

        Public Function Parse(ByVal input As String, ByVal tree As ParseTree) As ParseTree
            m_scanner.Init(input)

            m_tree = tree
            ParseStart(m_tree)
            m_tree.Skipped = m_scanner.Skipped

            Return m_tree
        End Function

        Private Sub ParseBINARYPREDICATECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: BINARYPREDICATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BINARYPREDICATECLAUSE), "BINARYPREDICATECLAUSE")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.PREDICATEPART) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATEPART

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATEPART) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: BINARYPREDICATECLAUSE

        Private Sub ParseFACTREADING(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTREADING
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTREADING), "FACTREADING")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.FRONTREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.FRONTREADINGTEXT Then
                ParseFRONTREADINGTEXTCLAUSE(node) ' NonTerminal Rule: FRONTREADINGTEXTCLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FRONTREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FRONTREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.SUBSCRIPT) ' Option Rule
            If tok.Type = TokenType.SUBSCRIPT Then
                tok = m_scanner.Scan(TokenType.SUBSCRIPT) ' Terminal Rule: SUBSCRIPT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.SUBSCRIPT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SUBSCRIPT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SUBSCRIPT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SUBSCRIPT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SUBSCRIPT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.UNARYPREDICATEPART, TokenType.PREDICATEPART) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.UNARYPREDICATEPART
                    ParseUNARYPREDICATECLAUSE(node) ' NonTerminal Rule: UNARYPREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREDICATEPART
                    ParseBINARYPREDICATECLAUSE(node) ' NonTerminal Rule: BINARYPREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYPREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "UNARYPREDICATEPART"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYPREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATEPART"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.FOLLOWINGREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTREADING

        Private Sub ParseFRONTREADINGTEXTCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: FRONTREADINGTEXTCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FRONTREADINGTEXTCLAUSE), "FRONTREADINGTEXTCLAUSE")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.FRONTREADINGTEXT) ' ZeroOrMore Rule
            While tok.Type = TokenType.FRONTREADINGTEXT

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.FRONTREADINGTEXT) ' Terminal Rule: FRONTREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.FRONTREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FRONTREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FRONTREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' Option Rule
                If tok.Type = TokenType.PREDICATESPACE Then
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Else
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.FRONTREADINGTEXT) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FRONTREADINGTEXTCLAUSE

        Private Sub ParseMODELELEMENT(ByVal parent As ParseNode) ' NonTerminalSymbol: MODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENT), "MODELELEMENT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.PREBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.PREBOUNDREADINGTEXT) ' Terminal Rule: PREBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.POSTBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.POSTBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.POSTBOUNDREADINGTEXT) ' Terminal Rule: POSTBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.POSTBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MODELELEMENT

        Private Sub ParsePREDICATECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: PREDICATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PREDICATECLAUSE), "PREDICATECLAUSE")
            parent.Nodes.Add(node)

            Do ' OneOrMore Rule
                tok = m_scanner.Scan(TokenType.PREDICATEPART) ' Terminal Rule: PREDICATEPART
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREDICATEPART Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATEPART"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATEPART) ' OneOrMore Rule
            Loop While tok.Type = TokenType.PREDICATEPART ' OneOrMore Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: PREDICATECLAUSE

        Private Sub ParseUNARYPREDICATECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: UNARYPREDICATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.UNARYPREDICATECLAUSE), "UNARYPREDICATECLAUSE")
            parent.Nodes.Add(node)

            Do ' OneOrMore Rule
                tok = m_scanner.Scan(TokenType.UNARYPREDICATEPART) ' Terminal Rule: UNARYPREDICATEPART
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.UNARYPREDICATEPART Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYPREDICATEPART.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "UNARYPREDICATEPART"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.UNARYPREDICATEPART) ' OneOrMore Rule
            Loop While tok.Type = TokenType.UNARYPREDICATEPART ' OneOrMore Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: UNARYPREDICATECLAUSE

        Private Sub ParseStart(ByVal parent As ParseNode) ' NonTerminalSymbol: Start
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.Start), "Start")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseFACTREADING(node) ' NonTerminal Rule: FACTREADING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: Start


    End Class
#End Region
End Namespace

