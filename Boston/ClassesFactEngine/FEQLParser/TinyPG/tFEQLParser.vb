' Generated by TinyPG v1.3 available at www.codeproject.com

Imports System
Imports System.Collections.Generic


Namespace FEQL
#Region "Parser"

    Partial Public Class Parser 
        Private m_scanner As Scanner
        Private m_tree As ParseTree

        Public Sub New(ByVal scanner As Scanner)
            m_scanner = scanner
        End Sub


    Public Function Parse(ByVal input As String) As ParseTree
            m_tree = New ParseTree()
            Return Parse(input, m_tree)
        End Function

        Public Function Parse(ByVal input As String, ByVal tree As ParseTree) As ParseTree
            m_scanner.Init(input)

            m_tree = tree
            ParseStart(m_tree)
            m_tree.Skipped = m_scanner.Skipped

            Return m_tree
        End Function

        Private Function ParseCOMPARITOR(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: COMPARITOR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COMPARITOR), "COMPARITOR")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.EQUALS, TokenType.KEYWDLESSTHAN, TokenType.KEYWDGREATERTHAN}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.EQUALS
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EQUALS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDLESSTHAN
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDLESSTHAN) ' Terminal Rule: KEYWDLESSTHAN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDLESSTHAN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLESSTHAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLESSTHAN"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDGREATERTHAN
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDGREATERTHAN) ' Terminal Rule: KEYWDGREATERTHAN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDGREATERTHAN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDGREATERTHAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDGREATERTHAN"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLESSTHAN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDGREATERTHAN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDLESSTHAN) ' Terminal Rule: KEYWDLESSTHAN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDLESSTHAN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLESSTHAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLESSTHAN"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDGREATERTHAN) ' Terminal Rule: KEYWDGREATERTHAN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDGREATERTHAN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDGREATERTHAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDGREATERTHAN"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: COMPARITOR

        Private Function ParseAddExpr(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: AddExpr
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.AddExpr), "AddExpr")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseMultExpr(node) ' NonTerminal Rule: MultExpr
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PLUS, TokenType.MINUS) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PLUS Or tok.Type = TokenType.MINUS
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        tok = m_scanner.LookAhead({TokenType.PLUS, TokenType.MINUS}) ' Choice Rule
                                Select Case tok.Type
                                 ' Choice Rule
                                    Case TokenType.PLUS
                                                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.PLUS) ' Terminal Rule: PLUS
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.PLUS Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PLUS"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    Case TokenType.MINUS
                                                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.MINUS) ' Terminal Rule: MINUS
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.MINUS Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MINUS"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    Case Else
                                    If m_tree.Errors.Count = 0 Then
                                    m_tree.Optionals.Clear
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PLUS"))
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MINUS"))
                                    End If
                                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                        Exit Select
                                End Select ' Choice Rule
                                    If Not lbProblemSolved Then
                                       m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.MINUS) ' Terminal Rule: MINUS
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.MINUS Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MINUS"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    End If
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseMultExpr(node) ' NonTerminal Rule: MultExpr
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PLUS, TokenType.MINUS) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: AddExpr

        Private Function ParseMultExpr(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MultExpr
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MultExpr), "MultExpr")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseAtom(node) ' NonTerminal Rule: Atom
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.TIMES, TokenType.DIVIDE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.TIMES Or tok.Type = TokenType.DIVIDE
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        tok = m_scanner.LookAhead({TokenType.TIMES, TokenType.DIVIDE}) ' Choice Rule
                                Select Case tok.Type
                                 ' Choice Rule
                                    Case TokenType.TIMES
                                                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.TIMES) ' Terminal Rule: TIMES
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.TIMES Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TIMES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "TIMES"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    Case TokenType.DIVIDE
                                                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.DIVIDE) ' Terminal Rule: DIVIDE
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.DIVIDE Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIVIDE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "DIVIDE"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    Case Else
                                    If m_tree.Errors.Count = 0 Then
                                    m_tree.Optionals.Clear
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TIMES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "TIMES"))
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TIMES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "DIVIDE"))
                                    End If
                                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                        Exit Select
                                End Select ' Choice Rule
                                    If Not lbProblemSolved Then
                                       m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.DIVIDE) ' Terminal Rule: DIVIDE
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.DIVIDE Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIVIDE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "DIVIDE"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    End If
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseAtom(node) ' NonTerminal Rule: Atom
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.TIMES, TokenType.DIVIDE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MultExpr

        Private Function ParseAtom(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: Atom
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.Atom), "Atom")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDTODAY, TokenType.NUMBER, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDTODAY
                                tok = m_scanner.LookAhead({TokenType.KEYWDTODAY, TokenType.NUMBER, TokenType.MODELELEMENTNAME}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDTODAY
                    lbProblemSolved =                             ParseRESERVEDWORD(node) ' NonTerminal Rule: RESERVEDWORD
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.NUMBER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.MODELELEMENTNAME
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTODAY"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

                Case TokenType.NUMBER
                                tok = m_scanner.LookAhead({TokenType.KEYWDTODAY, TokenType.NUMBER, TokenType.MODELELEMENTNAME}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDTODAY
                    lbProblemSolved =                             ParseRESERVEDWORD(node) ' NonTerminal Rule: RESERVEDWORD
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.NUMBER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.MODELELEMENTNAME
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTODAY"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

                Case TokenType.MODELELEMENTNAME
                                tok = m_scanner.LookAhead({TokenType.KEYWDTODAY, TokenType.NUMBER, TokenType.MODELELEMENTNAME}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDTODAY
                    lbProblemSolved =                             ParseRESERVEDWORD(node) ' NonTerminal Rule: RESERVEDWORD
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.NUMBER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.MODELELEMENTNAME
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTODAY"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

                Case TokenType.BROPEN
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BROPEN Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                    lbProblemSolved =                             ParseAddExpr(node) ' NonTerminal Rule: AddExpr
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BRCLOSE Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                              lbProblemSolved = False
                              Return False

                            End If


            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTODAY"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BROPEN Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                    lbProblemSolved =                             ParseAddExpr(node) ' NonTerminal Rule: AddExpr
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BRCLOSE Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                              lbProblemSolved = False
                              Return False

                            End If


            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: Atom

        Private Function ParseFORMULA(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FORMULA
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FORMULA), "FORMULA")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseAddExpr(node) ' NonTerminal Rule: AddExpr
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseCOMPARITOR(node) ' NonTerminal Rule: COMPARITOR
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseAddExpr(node) ' NonTerminal Rule: AddExpr
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FORMULA

        Private Function ParseRESERVEDWORD(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: RESERVEDWORD
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RESERVEDWORD), "RESERVEDWORD")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            lbProblemSolved = True
            tok = m_scanner.Scan(TokenType.KEYWDTODAY) ' Terminal Rule: KEYWDTODAY
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTODAY Then
              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTODAY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTODAY"))
              lbProblemSolved = False
              Return False

            End If


            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: RESERVEDWORD

        Private Function ParseADDITIONALMODELELEMENT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDITIONALMODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALMODELELEMENT), "ADDITIONALMODELELEMENT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDAND Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDITIONALMODELELEMENT

        Private Function ParseADDITIONALCOLUMNNAME(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDITIONALCOLUMNNAME
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALCOLUMNNAME), "ADDITIONALCOLUMNNAME")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDITIONALCOLUMNNAME

        Private Function ParseADDITIONALCOMPARISON(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDITIONALCOMPARISON
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALCOMPARISON), "ADDITIONALCOMPARISON")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDAND Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDITIONALCOMPARISON

        Private Function ParseADDITIONALQUOTEDIDENTIFIER(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDITIONALQUOTEDIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALQUOTEDIDENTIFIER), "ADDITIONALQUOTEDIDENTIFIER")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.IDENTIFIER, TokenType.SINGLEQUOTE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.IDENTIFIER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.IDENTIFIER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.SINGLEQUOTE
                    lbProblemSolved =                             ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseQUOTEDIDENTIFIER(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDITIONALQUOTEDIDENTIFIER

        Private Function ParseADDITIONALVALUE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDITIONALVALUE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALVALUE), "ADDITIONALVALUE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDITIONALVALUE

        Private Function ParseBRACKTEDCOLMNLIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: BRACKTEDCOLMNLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BRACKTEDCOLMNLIST), "BRACKTEDCOLMNLIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNLIST(node) ' NonTerminal Rule: COLUMNLIST
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: BRACKTEDCOLMNLIST

        Private Function ParseCOLUMNLIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: COLUMNLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COLUMNLIST), "COLUMNLIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear
                        ParseADDITIONALCOLUMNNAME(node) ' NonTerminal Rule: ADDITIONALCOLUMNNAME
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: COLUMNLIST

        Private Function ParseCOLUMNNAME(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: COLUMNNAME
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COLUMNNAME), "COLUMNNAME")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.STAR, TokenType.COLUMNNAMESTR, TokenType.KEYWDCOUNTSTAR}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.STAR
                                tok = m_scanner.LookAhead({TokenType.STAR}) ' Option Rule
                    If tok.Type = TokenType.STAR Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.STAR Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

                Case TokenType.COLUMNNAMESTR
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COLUMNNAMESTR) ' Terminal Rule: COLUMNNAMESTR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLUMNNAMESTR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDCOUNTSTAR
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCOUNTSTAR) ' Terminal Rule: KEYWDCOUNTSTAR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCOUNTSTAR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNTSTAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COLUMNNAMESTR) ' Terminal Rule: COLUMNNAMESTR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLUMNNAMESTR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCOUNTSTAR) ' Terminal Rule: KEYWDCOUNTSTAR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCOUNTSTAR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNTSTAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: COLUMNNAME

        Private Function ParseCOMPARISON(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: COMPARISON
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COMPARISON), "COMPARISON")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.WHERECLAUSECOLUMNNAMESTR) ' Terminal Rule: WHERECLAUSECOLUMNNAMESTR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.WHERECLAUSECOLUMNNAMESTR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHERECLAUSECOLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "WHERECLAUSECOLUMNNAMESTR"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EQUALS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: COMPARISON

        Private Function ParseCOMPARISONLIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: COMPARISONLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COMPARISONLIST), "COMPARISONLIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseADDITIONALCOMPARISON(node) ' NonTerminal Rule: ADDITIONALCOMPARISON
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: COMPARISONLIST

        Private Function ParseDATATYPE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DATATYPE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATATYPE), "DATATYPE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDDATATYPELOGICALTRUEFALSE, TokenType.KEYWDDATATYPELOGICALYESNO, TokenType.KEYWDDATATYPEAUTOCOUNTER, TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION, TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION, TokenType.KEYWDDATATYPESIGNEDBIGINTEGER, TokenType.KEYWDDATATYPESIGNEDINTEGER, TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER, TokenType.KEYWDDATATYPEOBJECTID, TokenType.KEYWDDATATYPEROWID, TokenType.KEYWDDATATYPERAWDATAOLEOBJECT, TokenType.KEYWDDATATYPERAWDATA, TokenType.KEYWDDATATYPEAUTOTIMESTAMP, TokenType.KEYWDDATATYPEDATE, TokenType.KEYWDDATATYPEDATETIME, TokenType.KEYWDDATATYPETIME}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDDATATYPELOGICALTRUEFALSE
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPELOGICALTRUEFALSE) ' Terminal Rule: KEYWDDATATYPELOGICALTRUEFALSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPELOGICALTRUEFALSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPELOGICALYESNO
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPELOGICALYESNO) ' Terminal Rule: KEYWDDATATYPELOGICALYESNO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPELOGICALYESNO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALYESNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEAUTOCOUNTER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEAUTOCOUNTER) ' Terminal Rule: KEYWDDATATYPEAUTOCOUNTER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEAUTOCOUNTER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEAUTOCOUNTER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATDOUBLEPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATSINGLEPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPESIGNEDBIGINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDBIGINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDBIGINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDBIGINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDBIGINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPESIGNEDINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDSMALLINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEUNSIGNEDINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEOBJECTID
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEOBJECTID) ' Terminal Rule: KEYWDDATATYPEOBJECTID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEOBJECTID Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEOBJECTID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEROWID
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEROWID) ' Terminal Rule: KEYWDDATATYPEROWID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEROWID Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEROWID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPERAWDATAOLEOBJECT
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAOLEOBJECT) ' Terminal Rule: KEYWDDATATYPERAWDATAOLEOBJECT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATAOLEOBJECT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAOLEOBJECT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPERAWDATA
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATA) ' Terminal Rule: KEYWDDATATYPERAWDATA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEAUTOTIMESTAMP
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEAUTOTIMESTAMP) ' Terminal Rule: KEYWDDATATYPEAUTOTIMESTAMP
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEAUTOTIMESTAMP Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEAUTOTIMESTAMP.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEDATE
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDATE) ' Terminal Rule: KEYWDDATATYPEDATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPEDATETIME
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDATETIME) ' Terminal Rule: KEYWDDATATYPEDATETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDATETIME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDATETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDDATATYPETIME
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPETIME) ' Terminal Rule: KEYWDDATATYPETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPETIME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPELOGICALYESNO) ' Terminal Rule: KEYWDDATATYPELOGICALYESNO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPELOGICALYESNO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALYESNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEAUTOCOUNTER) ' Terminal Rule: KEYWDDATATYPEAUTOCOUNTER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEAUTOCOUNTER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEAUTOCOUNTER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATDOUBLEPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATSINGLEPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDBIGINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDBIGINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDBIGINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDBIGINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDSMALLINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEOBJECTID) ' Terminal Rule: KEYWDDATATYPEOBJECTID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEOBJECTID Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEOBJECTID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEROWID) ' Terminal Rule: KEYWDDATATYPEROWID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEROWID Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEROWID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAOLEOBJECT) ' Terminal Rule: KEYWDDATATYPERAWDATAOLEOBJECT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATAOLEOBJECT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAOLEOBJECT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATA) ' Terminal Rule: KEYWDDATATYPERAWDATA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEAUTOTIMESTAMP) ' Terminal Rule: KEYWDDATATYPEAUTOTIMESTAMP
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEAUTOTIMESTAMP Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEAUTOTIMESTAMP.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDATE) ' Terminal Rule: KEYWDDATATYPEDATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDATETIME) ' Terminal Rule: KEYWDDATATYPEDATETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDATETIME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDATETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPETIME) ' Terminal Rule: KEYWDDATATYPETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPETIME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DATATYPE

        Private Function ParseDATATYPELENGTH(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DATATYPELENGTH
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATATYPELENGTH), "DATATYPELENGTH")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH, TokenType.KEYWDDATATYPERAWDATALARGELENGTH, TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH, TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH, TokenType.KEYWDDATATYPESTRINGLARGELENGTH, TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATAFIXEDLENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPERAWDATALARGELENGTH
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATALARGELENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATALARGELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPERAWDATALARGELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATALARGELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATAVARIABLELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGFIXEDLENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPESTRINGLARGELENGTH
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGLARGELENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGLARGELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPESTRINGLARGELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGLARGELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGVARIABLELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATALARGELENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATALARGELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPERAWDATALARGELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATALARGELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATAVARIABLELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGFIXEDLENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGLARGELENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGLARGELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPESTRINGLARGELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGLARGELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGVARIABLELENGTH
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.NUMBER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DATATYPELENGTH

        Private Function ParseDATATYPEPRECISION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DATATYPEPRECISION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATATYPEPRECISION), "DATATYPEPRECISION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION, TokenType.KEYWDDATATYPEDECIMAL, TokenType.KEYWDDATATYPEMONEY}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATCUSTOMPRECISION
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPEDECIMAL
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDECIMAL) ' Terminal Rule: KEYWDDATATYPEDECIMAL
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPEDECIMAL Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDECIMAL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDDATATYPEMONEY
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPEMONEY) ' Terminal Rule: KEYWDDATATYPEMONEY
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPEMONEY Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEMONEY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDECIMAL) ' Terminal Rule: KEYWDDATATYPEDECIMAL
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPEDECIMAL Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDECIMAL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDDATATYPEMONEY) ' Terminal Rule: KEYWDDATATYPEMONEY
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDDATATYPEMONEY Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEMONEY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.NUMBER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DATATYPEPRECISION

        Private Function ParseFACTPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTPREDICATE), "FACTPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            ParseNODEPROPERTYNAMEIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYNAMEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
              lbProblemSolved = False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTPREDICATE

        Private Function ParseFACTREADING(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTREADING
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTREADING), "FACTREADING")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                Do ' OneOrMore Rule

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME}) ' Option Rule
                                If tok.Type = TokenType.MODELELEMENTNAME Then
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Else
                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                End If
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                        tok = m_scanner.LookAhead(TokenType.PREDICATE) ' OneOrMore Rule
                    Loop While tok.Type = TokenType.PREDICATE ' OneOrMore Rule
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTREADING

        Private Function ParseFACTTYPENAMESTR(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPENAMESTR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPENAMESTR), "FACTTYPENAMESTR")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.FACTTYPENAME) ' Terminal Rule: FACTTYPENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.FACTTYPENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FACTTYPENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FACTTYPENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPENAMESTR

        Private Function ParseFACTTYPEPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEPREDICATE), "FACTTYPEPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                While tok.Type = TokenType.PREDICATESPACE
                                m_tree.Errors.Clear
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATESPACE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If

                                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPEPREDICATE

        Private Function ParseFACTTYPESIMPLEPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPESIMPLEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPESIMPLEPREDICATE), "FACTTYPESIMPLEPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                While tok.Type = TokenType.PREDICATESPACE
                                m_tree.Errors.Clear
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATESPACE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If

                                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPESIMPLEPREDICATE

        Private Function ParseINSERTCOLUMNLIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: INSERTCOLUMNLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INSERTCOLUMNLIST), "INSERTCOLUMNLIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear
                        ParseADDITIONALCOLUMNNAME(node) ' NonTerminal Rule: ADDITIONALCOLUMNNAME
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: INSERTCOLUMNLIST

        Private Function ParseMATCHPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MATCHPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHPREDICATE), "MATCHPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                While tok.Type = TokenType.PREDICATESPACE
                                m_tree.Errors.Clear
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATESPACE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If

                                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MATCHPREDICATE

        Private Function ParseMATCHFACTTYPEPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MATCHFACTTYPEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHFACTTYPEPREDICATE), "MATCHFACTTYPEPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                While tok.Type = TokenType.PREDICATESPACE
                                m_tree.Errors.Clear
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATESPACE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If

                                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MATCHFACTTYPEPREDICATE

        Private Function ParseMODELELEMENT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENT), "MODELELEMENT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.PREBOUNDREADINGTEXT}) ' Option Rule
                    If tok.Type = TokenType.PREBOUNDREADINGTEXT Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.PREBOUNDREADINGTEXT) ' Terminal Rule: PREBOUNDREADINGTEXT
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.PREBOUNDREADINGTEXT Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.POSTBOUNDREADINGTEXT}) ' Option Rule
                    If tok.Type = TokenType.POSTBOUNDREADINGTEXT Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.POSTBOUNDREADINGTEXT) ' Terminal Rule: POSTBOUNDREADINGTEXT
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.POSTBOUNDREADINGTEXT Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTSUFFIX}) ' Option Rule
                    If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MODELELEMENT

        Private Function ParseMODELELEMENTPLURAL(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MODELELEMENTPLURAL
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENTPLURAL), "MODELELEMENTPLURAL")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDENTITYTYPES, TokenType.KEYWDVALUETYPES, TokenType.KEYWDFACTTYPES, TokenType.KEYWDROLECONSTRAINTS, TokenType.KEYWDMODELNOTES}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPES
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPES) ' Terminal Rule: KEYWDENTITYTYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENTITYTYPES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPES"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDVALUETYPES
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPES) ' Terminal Rule: KEYWDVALUETYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPES"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDFACTTYPES
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFACTTYPES) ' Terminal Rule: KEYWDFACTTYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFACTTYPES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPES"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDROLECONSTRAINTS
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDROLECONSTRAINTS) ' Terminal Rule: KEYWDROLECONSTRAINTS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDROLECONSTRAINTS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDROLECONSTRAINTS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLECONSTRAINTS"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDMODELNOTES
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMODELNOTES) ' Terminal Rule: KEYWDMODELNOTES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODELNOTES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODELNOTES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODELNOTES"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPES"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPES"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPES"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLECONSTRAINTS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODELNOTES"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPES) ' Terminal Rule: KEYWDVALUETYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPES"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFACTTYPES) ' Terminal Rule: KEYWDFACTTYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFACTTYPES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPES"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDROLECONSTRAINTS) ' Terminal Rule: KEYWDROLECONSTRAINTS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDROLECONSTRAINTS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDROLECONSTRAINTS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLECONSTRAINTS"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMODELNOTES) ' Terminal Rule: KEYWDMODELNOTES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODELNOTES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODELNOTES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODELNOTES"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MODELELEMENTPLURAL

        Private Function ParseMODELELEMENTSTR(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MODELELEMENTSTR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENTSTR), "MODELELEMENTSTR")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MODELELEMENTSTR

        Private Function ParseMODELMODELELEMENT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MODELMODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELMODELELEMENT), "MODELMODELELEMENT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDENTITYTYPE, TokenType.KEYWDVALUETYPE, TokenType.KEYWDMODEL}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPE
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPE) ' Terminal Rule: KEYWDENTITYTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENTITYTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDVALUETYPE
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDMODEL
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODEL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODEL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MODELMODELELEMENT

        Private Function ParseNODESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NODESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODESTMT), "NODESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COLON) ' Terminal Rule: COLON
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLON Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.IDENTIFIER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NODESTMT

        Private Function ParseNODE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NODE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODE), "NODE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.PREBOUNDREADINGTEXT}) ' Option Rule
                    If tok.Type = TokenType.PREBOUNDREADINGTEXT Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.PREBOUNDREADINGTEXT) ' Terminal Rule: PREBOUNDREADINGTEXT
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.PREBOUNDREADINGTEXT Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.MODELELEMENTNAME
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTSUFFIX}) ' Option Rule
                                    If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                                        lbProblemSolved = True
                                        tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                                        n = node.CreateNode(tok, tok.ToString() )
                                        node.Token.UpdateRange(tok)
                                        node.Nodes.Add(n)
                                        If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                                          lbProblemSolved = False
                                          Return False

                                        End If


                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.BROPEN
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.POSTBOUNDREADINGTEXT}) ' Option Rule
                    If tok.Type = TokenType.POSTBOUNDREADINGTEXT Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.POSTBOUNDREADINGTEXT) ' Terminal Rule: POSTBOUNDREADINGTEXT
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.POSTBOUNDREADINGTEXT Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NODE

        Private Function ParseNODEPROPERTYIDENTIFICATION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NODEPROPERTYIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODEPROPERTYIDENTIFICATION), "NODEPROPERTYIDENTIFICATION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTSUFFIX}) ' Option Rule
                    If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COLON, TokenType.CARRET) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COLON Or tok.Type = TokenType.CARRET
                    m_tree.Errors.Clear
                        ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.COLON, TokenType.CARRET) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NODEPROPERTYIDENTIFICATION

        Private Function ParseNODEPROPERTYNAMEIDENTIFICATION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NODEPROPERTYNAMEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODEPROPERTYNAMEIDENTIFICATION), "NODEPROPERTYNAMEIDENTIFICATION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.MODELELEMENTNAME
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.BROPEN
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BROPEN Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.OPENPARENTHESIS, TokenType.COLON, TokenType.CARRET}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.OPENPARENTHESIS
                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                    While tok.Type = TokenType.OPENPARENTHESIS
                                    m_tree.Errors.Clear
                                        ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If
                                    tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                    If Not lbProblemSolved Then Exit While
                                    End While
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

                                Case TokenType.COLON
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.OPENPARENTHESIS
                                            m_tree.Errors.Clear
                                                ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case TokenType.CARRET
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.OPENPARENTHESIS
                                            m_tree.Errors.Clear
                                                ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENPARENTHESIS"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.OPENPARENTHESIS
                                            m_tree.Errors.Clear
                                                ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BRCLOSE Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                              lbProblemSolved = False
                              Return False

                            End If


            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BROPEN Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.OPENPARENTHESIS, TokenType.COLON, TokenType.CARRET}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.OPENPARENTHESIS
                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                    While tok.Type = TokenType.OPENPARENTHESIS
                                    m_tree.Errors.Clear
                                        ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If
                                    tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                    If Not lbProblemSolved Then Exit While
                                    End While
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

                                Case TokenType.COLON
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.OPENPARENTHESIS
                                            m_tree.Errors.Clear
                                                ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case TokenType.CARRET
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.OPENPARENTHESIS
                                            m_tree.Errors.Clear
                                                ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENPARENTHESIS"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.OPENPARENTHESIS
                                            m_tree.Errors.Clear
                                                ParseQUOTEDPROPERTYIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDPROPERTYIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.OPENPARENTHESIS) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.BRCLOSE Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                              lbProblemSolved = False
                              Return False

                            End If


            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NODEPROPERTYNAMEIDENTIFICATION

        Private Function ParseNODEIDENTIFICATION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NODEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODEIDENTIFICATION), "NODEIDENTIFICATION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.BROPEN}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.BROPEN
            lbProblemSolved =                     ParseMATCHPREDICATE(node) ' NonTerminal Rule: MATCHPREDICATE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.BROPEN
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NODEIDENTIFICATION

        Private Function ParseNUMBER1(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NUMBER1
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NUMBER1), "NUMBER1")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            lbProblemSolved = True
            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.NUMBER Then
              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
              lbProblemSolved = False
              Return False

            End If


            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NUMBER1

        Private Function ParseNUMBER2(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: NUMBER2
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NUMBER2), "NUMBER2")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            lbProblemSolved = True
            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.NUMBER Then
              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
              lbProblemSolved = False
              Return False

            End If


            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: NUMBER2

        Private Function ParsePREDICATECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: PREDICATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PREDICATECLAUSE), "PREDICATECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            Do ' OneOrMore Rule
                lbProblemSolved = True
                tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREDICATE Then
                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                  lbProblemSolved = False
                  Return False

                End If

                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' OneOrMore Rule
            Loop While tok.Type = TokenType.PREDICATE ' OneOrMore Rule
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: PREDICATECLAUSE

        Private Function ParsePROPERTYIDENTIFIER(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: PROPERTYIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PROPERTYIDENTIFIER), "PROPERTYIDENTIFIER")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COLUMNNAMESTR) ' Terminal Rule: COLUMNNAMESTR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLUMNNAMESTR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COLON) ' Terminal Rule: COLON
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLON Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.IDENTIFIER, TokenType.SINGLEQUOTE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.IDENTIFIER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.IDENTIFIER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.SINGLEQUOTE
                    lbProblemSolved =                             ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseQUOTEDIDENTIFIER(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: PROPERTYIDENTIFIER

        Private Function ParseQUOTEDIDENTIFIER(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: QUOTEDIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.QUOTEDIDENTIFIER), "QUOTEDIDENTIFIER")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.EMAILADDRESS, TokenType.IDENTIFIER}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.EMAILADDRESS
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.EMAILADDRESS) ' Terminal Rule: EMAILADDRESS
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.EMAILADDRESS Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EMAILADDRESS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EMAILADDRESS"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.IDENTIFIER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.IDENTIFIER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EMAILADDRESS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EMAILADDRESS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EMAILADDRESS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.IDENTIFIER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: QUOTEDIDENTIFIER

        Private Function ParseQUOTEDIDENTIFIERLIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: QUOTEDIDENTIFIERLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.QUOTEDIDENTIFIERLIST), "QUOTEDIDENTIFIERLIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.COLON, TokenType.CARRET}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.COLON
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.COLON) ' Terminal Rule: COLON
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.COLON Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.CARRET
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.CARRET) ' Terminal Rule: CARRET
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.CARRET Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CARRET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.CARRET) ' Terminal Rule: CARRET
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.CARRET Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CARRET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.IDENTIFIER, TokenType.SINGLEQUOTE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.IDENTIFIER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.IDENTIFIER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.SINGLEQUOTE
                    lbProblemSolved =                             ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseQUOTEDIDENTIFIER(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear
                        ParseADDITIONALQUOTEDIDENTIFIER(node) ' NonTerminal Rule: ADDITIONALQUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: QUOTEDIDENTIFIERLIST

        Private Function ParseQUOTEDPROPERTYIDENTIFIERLIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: QUOTEDPROPERTYIDENTIFIERLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.QUOTEDPROPERTYIDENTIFIERLIST), "QUOTEDPROPERTYIDENTIFIERLIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.OPENPARENTHESIS) ' Terminal Rule: OPENPARENTHESIS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.OPENPARENTHESIS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENPARENTHESIS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParsePROPERTYIDENTIFIER(node) ' NonTerminal Rule: PROPERTYIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.COMMA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParsePROPERTYIDENTIFIER(node) ' NonTerminal Rule: PROPERTYIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.CLOSEPARENTHESIS) ' Terminal Rule: CLOSEPARENTHESIS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.CLOSEPARENTHESIS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEPARENTHESIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CLOSEPARENTHESIS"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: QUOTEDPROPERTYIDENTIFIERLIST

        Private Function ParseRECURSIVECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: RECURSIVECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RECURSIVECLAUSE), "RECURSIVECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.OPENSQUAREBRACKET) ' Terminal Rule: OPENSQUAREBRACKET
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.OPENSQUAREBRACKET Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUAREBRACKET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENSQUAREBRACKET"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDCIRCULAR, TokenType.NUMBER, TokenType.PERIOD, TokenType.KEYWDSHORTESTPATH}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDCIRCULAR
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDCIRCULAR) ' Terminal Rule: KEYWDCIRCULAR
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDCIRCULAR Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCIRCULAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCIRCULAR"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.NUMBER
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER1(node) ' NonTerminal Rule: NUMBER1
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER2(node) ' NonTerminal Rule: NUMBER2
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.PERIOD
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER1(node) ' NonTerminal Rule: NUMBER1
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER2(node) ' NonTerminal Rule: NUMBER2
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.KEYWDSHORTESTPATH
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDSHORTESTPATH) ' Terminal Rule: KEYWDSHORTESTPATH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDSHORTESTPATH Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSHORTESTPATH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHORTESTPATH"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER1(node) ' NonTerminal Rule: NUMBER1
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER2(node) ' NonTerminal Rule: NUMBER2
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCIRCULAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCIRCULAR"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCIRCULAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCIRCULAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCIRCULAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHORTESTPATH"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER1(node) ' NonTerminal Rule: NUMBER1
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER2(node) ' NonTerminal Rule: NUMBER2
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDSHORTESTPATH) ' Terminal Rule: KEYWDSHORTESTPATH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDSHORTESTPATH Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSHORTESTPATH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHORTESTPATH"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER1(node) ' NonTerminal Rule: NUMBER1
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PERIOD Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.NUMBER}) ' Option Rule
                                    If tok.Type = TokenType.NUMBER Then
lbProblemSolved =                                         ParseNUMBER2(node) ' NonTerminal Rule: NUMBER2
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.CLOSESQUAREBRACKET) ' Terminal Rule: CLOSESQUAREBRACKET
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.CLOSESQUAREBRACKET Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSESQUAREBRACKET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CLOSESQUAREBRACKET"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: RECURSIVECLAUSE

        Private Function ParseREFERENCEMODECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: REFERENCEMODECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.REFERENCEMODECLAUSE), "REFERENCEMODECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISIDENTIFIEDBYITS) ' Terminal Rule: KEYWDISIDENTIFIEDBYITS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISIDENTIFIEDBYITS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISIDENTIFIEDBYITS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.REFERENCEMODE) ' Terminal Rule: REFERENCEMODE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.REFERENCEMODE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REFERENCEMODE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "REFERENCEMODE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDRESTRICTEDTO}) ' Option Rule
                    If tok.Type = TokenType.KEYWDRESTRICTEDTO Then

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDRESTRICTEDTO) ' Terminal Rule: KEYWDRESTRICTEDTO
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDRESTRICTEDTO Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRESTRICTEDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRESTRICTEDTO"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.CURLYBRACKETOPEN) ' Terminal Rule: CURLYBRACKETOPEN
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.CURLYBRACKETOPEN Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYBRACKETOPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CURLYBRACKETOPEN"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                                While tok.Type = TokenType.COMMA
                                m_tree.Errors.Clear

                                     ' Concat Rule
                                                                                lbProblemSolved = True
                                            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.COMMA Then
                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                              lbProblemSolved = False
                                              Return False

                                            End If



                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If


                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.CURLYBRACKETCLOSE) ' Terminal Rule: CURLYBRACKETCLOSE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.CURLYBRACKETCLOSE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYBRACKETCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CURLYBRACKETCLOSE"))
                                  lbProblemSolved = False
                                  Return False

                                End If


            If m_tree.Errors.Count > 0 Then
                              Return False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRESTRICTEDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRESTRICTEDTO"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: REFERENCEMODECLAUSE

        Private Function ParseRETURNCOLUMN(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: RETURNCOLUMN
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNCOLUMN), "RETURNCOLUMN")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.STAR, TokenType.KEYWDCOUNTSTAR, TokenType.MODELELEMENTNAME}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.STAR
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.STAR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.KEYWDCOUNTSTAR
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCOUNTSTAR) ' Terminal Rule: KEYWDCOUNTSTAR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCOUNTSTAR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNTSTAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.MODELELEMENTNAME
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTSUFFIX}) ' Option Rule
                            If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                                lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            Else
                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                            End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.PERIOD Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.COLUMNNAMESTR, TokenType.STAR}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.COLUMNNAMESTR
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.COLUMNNAMESTR) ' Terminal Rule: COLUMNNAMESTR
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.COLUMNNAMESTR Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case TokenType.STAR
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.STAR Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.STAR Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCOUNTSTAR) ' Terminal Rule: KEYWDCOUNTSTAR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCOUNTSTAR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNTSTAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                      lbProblemSolved = False
                      Return False

                    End If


                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTSUFFIX}) ' Option Rule
                            If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                                lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            Else
                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                            End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.PERIOD) ' Terminal Rule: PERIOD
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.PERIOD Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PERIOD"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.COLUMNNAMESTR, TokenType.STAR}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.COLUMNNAMESTR
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.COLUMNNAMESTR) ' Terminal Rule: COLUMNNAMESTR
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.COLUMNNAMESTR Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case TokenType.STAR
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.STAR Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.STAR Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: RETURNCOLUMN

        Private Function ParseRETURNCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: RETURNCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNCLAUSE), "RETURNCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDRETURN) ' Terminal Rule: KEYWDRETURN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDRETURN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRETURN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRETURN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseRETURNCOLUMN(node) ' NonTerminal Rule: RETURNCOLUMN
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.COMMA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseRETURNCOLUMN(node) ' NonTerminal Rule: RETURNCOLUMN
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: RETURNCLAUSE

        Private Function ParseRETURNFACTTYPEPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: RETURNFACTTYPEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNFACTTYPEPREDICATE), "RETURNFACTTYPEPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                While tok.Type = TokenType.PREDICATESPACE
                                m_tree.Errors.Clear
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATESPACE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If

                                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: RETURNFACTTYPEPREDICATE

        Private Function ParseRETURNPREDICATE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: RETURNPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNPREDICATE), "RETURNPREDICATE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                While tok.Type = TokenType.PREDICATESPACE
                                m_tree.Errors.Clear
                                    lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATESPACE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If

                                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                                If Not lbProblemSolved Then Exit While
                                End While
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: RETURNPREDICATE

        Private Function ParseROLENAMESTR(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ROLENAMESTR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ROLENAMESTR), "ROLENAMESTR")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.ROLENAME) ' Terminal Rule: ROLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.ROLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "ROLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ROLENAMESTR

        Private Function ParseSETCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: SETCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SETCLAUSE), "SETCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDSET) ' Terminal Rule: KEYWDSET
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDSET Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSET"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: SETCLAUSE

        Private Function ParseVALUELIST(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: VALUELIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.VALUELIST), "VALUELIST")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BROPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear
                        ParseADDITIONALVALUE(node) ' NonTerminal Rule: ADDITIONALVALUE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.BRCLOSE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: VALUELIST

        Private Function ParseVALUESTRING(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: VALUESTRING
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.VALUESTRING), "VALUESTRING")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.VALUE) ' Terminal Rule: VALUE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.VALUE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VALUE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "VALUE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: VALUESTRING

        Private Function ParseADDENTITYTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDENTITYTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDENTITYTYPESTMT), "ADDENTITYTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPE) ' Terminal Rule: KEYWDENTITYTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENTITYTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDPAGE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PAGENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDENTITYTYPESTMT

        Private Function ParseADDFACTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDFACTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDFACTSTMT), "ADDFACTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDADDFACT) ' Terminal Rule: KEYWDADDFACT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDADDFACT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADDFACT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDONPAGE}) ' Option Rule
                    If tok.Type = TokenType.KEYWDONPAGE Then

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDONPAGE) ' Terminal Rule: KEYWDONPAGE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDONPAGE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDONPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONPAGE"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.SINGLEQUOTE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.PAGENAME Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.SINGLEQUOTE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                  lbProblemSolved = False
                                  Return False

                                End If


            If m_tree.Errors.Count > 0 Then
                              Return False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDONPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONPAGE"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDFACTSTMT

        Private Function ParseADDFACTTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDFACTTYPESTMT), "ADDFACTTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFACTTYPE) ' Terminal Rule: KEYWDFACTTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFACTTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDPAGE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PAGENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDFACTTYPESTMT

        Private Function ParseADDROLESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDROLESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDROLESTMT), "ADDROLESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDROLE) ' Terminal Rule: KEYWDROLE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDROLE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDROLE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseROLENAMESTR(node) ' NonTerminal Rule: ROLENAMESTR
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFACTTYPE) ' Terminal Rule: KEYWDFACTTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFACTTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDJOINING) ' Terminal Rule: KEYWDJOINING
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDJOINING Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDJOINING.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDJOINING"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDROLESTMT

        Private Function ParseADDMODELELEMENTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDMODELELEMENTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDMODELELEMENTSTMT), "ADDMODELELEMENTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDADD) ' Terminal Rule: KEYWDADD
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDADD Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADD"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDENTITYTYPE, TokenType.KEYWDADDFACT, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE, TokenType.KEYWDROLE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDENTITYTYPE
                    lbProblemSolved =                             ParseADDENTITYTYPESTMT(node) ' NonTerminal Rule: ADDENTITYTYPESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDADDFACT
                    lbProblemSolved =                             ParseADDFACTSTMT(node) ' NonTerminal Rule: ADDFACTSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDFACTTYPE
                    lbProblemSolved =                             ParseADDFACTTYPESTMT(node) ' NonTerminal Rule: ADDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDVALUETYPE
                    lbProblemSolved =                             ParseADDVALUETYPESTMT(node) ' NonTerminal Rule: ADDVALUETYPESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDROLE
                    lbProblemSolved =                             ParseADDROLESTMT(node) ' NonTerminal Rule: ADDROLESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADDFACT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseADDFACTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ADDFACTSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseADDFACTTYPESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ADDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseADDVALUETYPESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ADDVALUETYPESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseADDROLESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ADDROLESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDMODELELEMENTSTMT

        Private Function ParseADDVALUETYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ADDVALUETYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDVALUETYPESTMT), "ADDVALUETYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDPAGE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PAGENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ADDVALUETYPESTMT

        Private Function ParseASSERTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ASSERTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ASSERTSTMT), "ASSERTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDASSERT) ' Terminal Rule: KEYWDASSERT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDASSERT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDASSERT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDASSERT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDISWRITTENAS, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDISWRITTENAS
                    lbProblemSolved =                             ParseVALUETYPEISWRITTENASSTMT(node) ' NonTerminal Rule: VALUETYPEISWRITTENASSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseFACTSTMT(node) ' NonTerminal Rule: FACTSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.BROPEN
                    lbProblemSolved =                             ParseFACTSTMT(node) ' NonTerminal Rule: FACTSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWRITTENAS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseFACTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: FACTSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ASSERTSTMT

        Private Function ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BINARYFACTTYPEMANYTOONEDEFINITIONSTMT), "BINARYFACTTYPEMANYTOONEDEFINITIONSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDONE) ' Terminal Rule: KEYWDONE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDONE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.ROLENAME}) ' Option Rule
                    If tok.Type = TokenType.ROLENAME Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.ROLENAME) ' Terminal Rule: ROLENAME
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.ROLENAME Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "ROLENAME"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "ROLENAME"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT

        Private Function ParseCONNECTTOMODELSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONNECTTOMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONNECTTOMODELSTMT), "CONNECTTOMODELSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCONNECTTOMODEL) ' Terminal Rule: KEYWDCONNECTTOMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCONNECTTOMODEL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCONNECTTOMODEL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.DATABASENAME) ' Terminal Rule: DATABASENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.DATABASENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DATABASENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "DATABASENAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONNECTTOMODELSTMT

        Private Function ParseCONSTRAINTEITHEROREXTERNAL(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTEITHEROREXTERNAL
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEITHEROREXTERNAL), "CONSTRAINTEITHEROREXTERNAL")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOR) ' Terminal Rule: KEYWDOR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOR"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDBUTNOTBOTH}) ' Option Rule
                    If tok.Type = TokenType.KEYWDBUTNOTBOTH Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.KEYWDBUTNOTBOTH) ' Terminal Rule: KEYWDBUTNOTBOTH
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDBUTNOTBOTH Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTEITHEROREXTERNAL

        Private Function ParseCONSTRAINTEITHERORSUBTYPE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTEITHERORSUBTYPE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEITHERORSUBTYPE), "CONSTRAINTEITHERORSUBTYPE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseSUBTYPESTMT(node) ' NonTerminal Rule: SUBTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOR) ' Terminal Rule: KEYWDOR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOR"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseSUBTYPESTMT(node) ' NonTerminal Rule: SUBTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDBUTNOTBOTH}) ' Option Rule
                    If tok.Type = TokenType.KEYWDBUTNOTBOTH Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.KEYWDBUTNOTBOTH) ' Terminal Rule: KEYWDBUTNOTBOTH
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDBUTNOTBOTH Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTEITHERORSUBTYPE

        Private Function ParseCONSTRAINTEITHEROR(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTEITHEROR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEITHEROR), "CONSTRAINTEITHEROR")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDEITHER) ' Terminal Rule: KEYWDEITHER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDEITHER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDEITHER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEITHER"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseCONSTRAINTEITHEROREXTERNAL(node) ' NonTerminal Rule: CONSTRAINTEITHEROREXTERNAL
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseCONSTRAINTEITHERORSUBTYPE(node) ' NonTerminal Rule: CONSTRAINTEITHERORSUBTYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseCONSTRAINTEITHERORSUBTYPE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CONSTRAINTEITHERORSUBTYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTEITHEROR

        Private Function ParseCONSTRAINTEXTERNALUNIQUENESS(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTEXTERNALUNIQUENESS
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEXTERNALUNIQUENESS), "CONSTRAINTEXTERNALUNIQUENESS")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCOMBINATION) ' Terminal Rule: KEYWDCOMBINATION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCOMBINATION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOMBINATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOMBINATION"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOF) ' Terminal Rule: KEYWDOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOF"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.COMMA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.MODELELEMENTNAME Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                  lbProblemSolved = False
                                  Return False

                                End If


            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOCCURSATLEASTONETIMEINEACHOF) ' Terminal Rule: KEYWDOCCURSATLEASTONETIMEINEACHOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOCCURSATLEASTONETIMEINEACHOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOCCURSATLEASTONETIMEINEACHOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOCCURSATLEASTONETIMEINEACHOF"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.COMMA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTEXTERNALUNIQUENESS

        Private Function ParseCONSTRAINTINCLUSIVEOR(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTINCLUSIVEOR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTINCLUSIVEOR), "CONSTRAINTINCLUSIVEOR")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDNULL) ' Terminal Rule: KEYWDNULL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDNULL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNULL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNULL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOCCURSATLEASTONETIME) ' Terminal Rule: KEYWDOCCURSATLEASTONETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOCCURSATLEASTONETIME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOCCURSATLEASTONETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOCCURSATLEASTONETIME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.COMMA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTINCLUSIVEOR

        Private Function ParseCONSTRAINTEXTERNALSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTEXTERNALSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEXTERNALSTMT), "CONSTRAINTEXTERNALSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDEACH) ' Terminal Rule: KEYWDEACH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDEACH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDEACH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEACH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDCOMBINATION, TokenType.KEYWDNULL}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDCOMBINATION
                    lbProblemSolved =                             ParseCONSTRAINTEXTERNALUNIQUENESS(node) ' NonTerminal Rule: CONSTRAINTEXTERNALUNIQUENESS
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDNULL
                    lbProblemSolved =                             ParseCONSTRAINTINCLUSIVEOR(node) ' NonTerminal Rule: CONSTRAINTINCLUSIVEOR
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOMBINATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOMBINATION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOMBINATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNULL"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseCONSTRAINTINCLUSIVEOR(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CONSTRAINTINCLUSIVEOR
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTEXTERNALSTMT

        Private Function ParseCONSTRAINTMANDATORY(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CONSTRAINTMANDATORY
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTMANDATORY), "CONSTRAINTMANDATORY")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISA) ' Terminal Rule: KEYWDISA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTHAT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDIFANDONLYIF) ' Terminal Rule: KEYWDIFANDONLYIF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDIFANDONLYIF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIFANDONLYIF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIFANDONLYIF"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseSUBTYPESTMT(node) ' NonTerminal Rule: SUBTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CONSTRAINTMANDATORY

        Private Function ParseCREATECONCEPTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATECONCEPTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATECONCEPTSTMT), "CREATECONCEPTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCREATECONCEPT) ' Terminal Rule: KEYWDCREATECONCEPT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCREATECONCEPT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCREATECONCEPT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATECONCEPT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATECONCEPTSTMT

        Private Function ParseCREATEDATABASESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATEDATABASESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEDATABASESTMT), "CREATEDATABASESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDATABASE) ' Terminal Rule: KEYWDDATABASE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATABASE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATABASE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.DATABASENAME) ' Terminal Rule: DATABASENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.DATABASENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DATABASENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "DATABASENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                Do ' OneOrMore Rule

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.SEMICOLON) ' Terminal Rule: SEMICOLON
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.SEMICOLON Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SEMICOLON"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseDATABASECREATECLAUSE(node) ' NonTerminal Rule: DATABASECREATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                        tok = m_scanner.LookAhead(TokenType.SEMICOLON) ' OneOrMore Rule
                    Loop While tok.Type = TokenType.SEMICOLON ' OneOrMore Rule
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATEDATABASESTMT

        Private Function ParseCREATEENTITYTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATEENTITYTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEENTITYTYPESTMT), "CREATEENTITYTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPE) ' Terminal Rule: KEYWDENTITYTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENTITYTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATEENTITYTYPESTMT

        Private Function ParseCREATEFACTTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATEFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEFACTTYPESTMT), "CREATEFACTTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFACTTYPE) ' Terminal Rule: KEYWDFACTTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFACTTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.SINGLEQUOTE}) ' Option Rule
                    If tok.Type = TokenType.SINGLEQUOTE Then
lbProblemSolved =                         ParseFACTTYPENAMESTR(node) ' NonTerminal Rule: FACTTYPENAMESTR
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFOR) ' Terminal Rule: KEYWDFOR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFOR Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFOR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFOR"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATEFACTTYPESTMT

        Private Function ParseCREATEMODELSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATEMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEMODELSTMT), "CREATEMODELSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCREATEMODEL) ' Terminal Rule: KEYWDCREATEMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCREATEMODEL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCREATEMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATEMODEL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATEMODELSTMT

        Private Function ParseCREATEMODELELEMENTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATEMODELELEMENTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEMODELELEMENTSTMT), "CREATEMODELELEMENTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPE
            lbProblemSolved =                     ParseCREATEENTITYTYPESTMT(node) ' NonTerminal Rule: CREATEENTITYTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDFACTTYPE
            lbProblemSolved =                     ParseCREATEFACTTYPESTMT(node) ' NonTerminal Rule: CREATEFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDVALUETYPE
            lbProblemSolved =                     ParseCREATEVALUETYPESTMT(node) ' NonTerminal Rule: CREATEVALUETYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseCREATEFACTTYPESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseCREATEVALUETYPESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEVALUETYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATEMODELELEMENTSTMT

        Private Function ParseCREATESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATESTMT), "CREATESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDCREATE) ' Terminal Rule: KEYWDCREATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCREATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCREATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDDATABASE, TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDDATABASE
                    lbProblemSolved =                             ParseCREATEDATABASESTMT(node) ' NonTerminal Rule: CREATEDATABASESTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDENTITYTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDFACTTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDVALUETYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDTHAT}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREDICATE
                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.PREDICATE
                                            m_tree.Errors.Clear
                                                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case TokenType.KEYWDTHAT
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.BROPEN
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDENTITYTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDFACTTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDVALUETYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDTHAT}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREDICATE
                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.PREDICATE
                                            m_tree.Errors.Clear
                                                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case TokenType.KEYWDTHAT
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.KEYWDENTITYTYPE
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDENTITYTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDFACTTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDVALUETYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDTHAT}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREDICATE
                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.PREDICATE
                                            m_tree.Errors.Clear
                                                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case TokenType.KEYWDTHAT
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.KEYWDFACTTYPE
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDENTITYTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDFACTTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDVALUETYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDTHAT}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREDICATE
                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.PREDICATE
                                            m_tree.Errors.Clear
                                                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case TokenType.KEYWDTHAT
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.KEYWDVALUETYPE
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDENTITYTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDFACTTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDVALUETYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDTHAT}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREDICATE
                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.PREDICATE
                                            m_tree.Errors.Clear
                                                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case TokenType.KEYWDTHAT
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATABASE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATABASE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDENTITYTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDFACTTYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDVALUETYPE
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseCREATEMODELELEMENTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDTHAT}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREDICATE
                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            While tok.Type = TokenType.PREDICATE
                                            m_tree.Errors.Clear
                                                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If
                                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                            If Not lbProblemSolved Then Exit While
                                            End While
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case TokenType.KEYWDTHAT
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDTHAT}) ' Option Rule
                                            If tok.Type = TokenType.KEYWDTHAT Then

                                                 ' Concat Rule
                                                                                                        lbProblemSolved = True
                                                        tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                        n = node.CreateNode(tok, tok.ToString() )
                                                        node.Token.UpdateRange(tok)
                                                        node.Nodes.Add(n)
                                                        If tok.Type <> TokenType.KEYWDTHAT Then
                                                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                          lbProblemSolved = False
                                                          Return False

                                                        End If



                                                 ' Concat Rule
                                                lbProblemSolved =                                                         ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                          lbProblemSolved = False
            End If


                                                 ' Concat Rule
                                                                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        While tok.Type = TokenType.KEYWDAND
                                                        m_tree.Errors.Clear

                                                             ' Concat Rule
                                                                                                                                lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.KEYWDAND Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If



                                                             ' Concat Rule
                                                            lbProblemSolved =                                                                     ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                                                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                                                  Return False
            End If
                                                        tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                                                        If Not lbProblemSolved Then Exit While
                                                        End While
            If m_tree.Errors.Count > 0 Then
                                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                      Return False
            End If

                                            Else
                                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                            End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATESTMT

        Private Function ParseCREATEVALUETYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: CREATEVALUETYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEVALUETYPESTMT), "CREATEVALUETYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: CREATEVALUETYPESTMT

        Private Function ParseDATABASECREATECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DATABASECREATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATABASECREATECLAUSE), "DATABASECREATECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDLOCATION, TokenType.KEYWDTYPE}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDLOCATION
            lbProblemSolved =                     ParseDATABASELOCATIONCLAUSE(node) ' NonTerminal Rule: DATABASELOCATIONCLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDTYPE
            lbProblemSolved =                     ParseDATABASETYPECLAUSE(node) ' NonTerminal Rule: DATABASETYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLOCATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLOCATION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLOCATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTYPE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDATABASETYPECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DATABASETYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DATABASECREATECLAUSE

        Private Function ParseDATABASELOCATIONCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DATABASELOCATIONCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATABASELOCATIONCLAUSE), "DATABASELOCATIONCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDLOCATION) ' Terminal Rule: KEYWDLOCATION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDLOCATION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLOCATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLOCATION"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EQUALS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.FILELOCATIONNAME) ' Terminal Rule: FILELOCATIONNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.FILELOCATIONNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILELOCATIONNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FILELOCATIONNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DATABASELOCATIONCLAUSE

        Private Function ParseDATABASETYPECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DATABASETYPECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATABASETYPECLAUSE), "DATABASETYPECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTYPE) ' Terminal Rule: KEYWDTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EQUALS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.DATABASETYPE) ' Terminal Rule: DATABASETYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.DATABASETYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DATABASETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "DATABASETYPE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DATABASETYPECLAUSE

        Private Function ParseDELETESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DELETESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETESTMT), "DELETESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDELETE) ' Terminal Rule: KEYWDDELETE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDELETE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDELETE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.BROPEN, TokenType.KEYWDFROM}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.BROPEN
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDFROM
                    lbProblemSolved =                             ParseDELETEFROMCLAUSE(node) ' NonTerminal Rule: DELETEFROMCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseDELETEFROMCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DELETEFROMCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DELETESTMT

        Private Function ParseDELETEFROMCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DELETEFROMCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETEFROMCLAUSE), "DELETEFROMCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFROM Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDON}) ' Option Rule
                    If tok.Type = TokenType.KEYWDON Then
lbProblemSolved =                         ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWHERE) ' Terminal Rule: KEYWDWHERE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWHERE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear
                        ParseADDITIONALCOMPARISON(node) ' NonTerminal Rule: ADDITIONALCOMPARISON
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DELETEFROMCLAUSE

        Private Function ParseDELETEALLSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DELETEALLSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETEALLSTMT), "DELETEALLSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDELETEALL) ' Terminal Rule: KEYWDDELETEALL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDELETEALL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDELETEALL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEALL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFROM Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DELETEALLSTMT

        Private Function ParseDELETEFACTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DELETEFACTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETEFACTSTMT), "DELETEFACTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDELETEFACT) ' Terminal Rule: KEYWDDELETEFACT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDELETEFACT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDELETEFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEFACT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFROM Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDON}) ' Option Rule
                    If tok.Type = TokenType.KEYWDON Then
lbProblemSolved =                         ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DELETEFACTSTMT

        Private Function ParseDERIVATIONCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DERIVATIONCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVATIONCLAUSE), "DERIVATIONCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISWHERE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseDERIVATIONSUBCLAUSE(node) ' NonTerminal Rule: DERIVATIONSUBCLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseDERIVATIONSUBCLAUSE(node) ' NonTerminal Rule: DERIVATIONSUBCLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DERIVATIONCLAUSE

        Private Function ParseDERIVATIONSUBCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DERIVATIONSUBCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVATIONSUBCLAUSE), "DERIVATIONSUBCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME, TokenType.KEYWDTODAY, TokenType.NUMBER, TokenType.BROPEN}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.MODELELEMENTNAME
            lbProblemSolved =                     ParseFACTREADING(node) ' NonTerminal Rule: FACTREADING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDTODAY
            lbProblemSolved =                     ParseDERIVATIONFORMULA(node) ' NonTerminal Rule: DERIVATIONFORMULA
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.NUMBER
            lbProblemSolved =                     ParseDERIVATIONFORMULA(node) ' NonTerminal Rule: DERIVATIONFORMULA
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.MODELELEMENTNAME
            lbProblemSolved =                     ParseDERIVATIONFORMULA(node) ' NonTerminal Rule: DERIVATIONFORMULA
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.BROPEN
            lbProblemSolved =                     ParseDERIVATIONFORMULA(node) ' NonTerminal Rule: DERIVATIONFORMULA
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTODAY"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDERIVATIONFORMULA(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DERIVATIONFORMULA
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DERIVATIONSUBCLAUSE

        Private Function ParseDERIVATIONFORMULA(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DERIVATIONFORMULA
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVATIONFORMULA), "DERIVATIONFORMULA")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            ParseFORMULA(node) ' NonTerminal Rule: FORMULA
            If m_tree.Errors.Count > 0 Then
              lbProblemSolved = False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DERIVATIONFORMULA

        Private Function ParseDERIVEDFACTTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DERIVEDFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVEDFACTTYPESTMT), "DERIVEDFACTTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDA, TokenType.KEYWDAN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDA
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDA Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.KEYWDAN
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDAN Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDAN Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWHEN) ' Terminal Rule: KEYWDWHEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWHEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESIMPLEPREDICATE(node) ' NonTerminal Rule: FACTTYPESIMPLEPREDICATE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                        lbProblemSolved =                                 ParseFACTTYPESIMPLEPREDICATE(node) ' NonTerminal Rule: FACTTYPESIMPLEPREDICATE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DERIVEDFACTTYPESTMT

        Private Function ParseDESCRIBESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DESCRIBESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DESCRIBESTMT), "DESCRIBESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDESCRIBE) ' Terminal Rule: KEYWDDESCRIBE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDESCRIBE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDESCRIBE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDESCRIBE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SPACE) ' Terminal Rule: SPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SPACE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SPACE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DESCRIBESTMT

        Private Function ParseDIDSELECTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: DIDSELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DIDSELECTSTMT), "DIDSELECTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDDID) ' Terminal Rule: KEYWDDID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDID Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDID"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDA}) ' Option Rule
                    If tok.Type = TokenType.KEYWDA Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDA Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.PREBOUNDREADINGTEXT
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.PREBOUNDREADINGTEXT
                    lbProblemSolved =                             ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.BROPEN
                    lbProblemSolved =                             ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND Or tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDWITH Or tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Or tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.BROPEN Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION
                    m_tree.Errors.Clear
                        ParseWHICHCLAUSE(node) ' NonTerminal Rule: WHICHCLAUSE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: DIDSELECTSTMT

        Private Function ParseENTITYTYPEISIDENTIFIEDBYITSCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ENTITYTYPEISIDENTIFIEDBYITSCLAUSE), "ENTITYTYPEISIDENTIFIEDBYITSCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISIDENTIFIEDBYITS) ' Terminal Rule: KEYWDISIDENTIFIEDBYITS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISIDENTIFIEDBYITS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISIDENTIFIEDBYITS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.REFERENCEMODE) ' Terminal Rule: REFERENCEMODE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.REFERENCEMODE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REFERENCEMODE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "REFERENCEMODE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDWRITTENAS}) ' Option Rule
                    If tok.Type = TokenType.KEYWDWRITTENAS Then
lbProblemSolved =                         ParseWRITTENASCLAUSE(node) ' NonTerminal Rule: WRITTENASCLAUSE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWRITTENAS"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE

        Private Function ParseENUMERATESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ENUMERATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ENUMERATESTMT), "ENUMERATESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDENUMERATE) ' Terminal Rule: KEYWDENUMERATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENUMERATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENUMERATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENUMERATE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SPACE) ' Terminal Rule: SPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SPACE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SPACE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDINDEX}) ' Option Rule
                    If tok.Type = TokenType.KEYWDINDEX Then

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDINDEX) ' Terminal Rule: KEYWDINDEX
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDINDEX Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINDEX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINDEX"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.SPACE) ' Terminal Rule: SPACE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.SPACE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SPACE"))
                                  lbProblemSolved = False
                                  Return False

                                End If


            If m_tree.Errors.Count > 0 Then
                              Return False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINDEX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINDEX"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ENUMERATESTMT

        Private Function ParseEXPRESSION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: EXPRESSION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXPRESSION), "EXPRESSION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EXPRESSIONSYMBOL) ' Terminal Rule: EXPRESSIONSYMBOL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EXPRESSIONSYMBOL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: EXPRESSION

        Private Function ParseEXPRESSIONPART(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: EXPRESSIONPART
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXPRESSIONPART), "EXPRESSIONPART")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EXPRESSIONSYMBOL) ' Terminal Rule: EXPRESSIONSYMBOL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EXPRESSIONSYMBOL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.MATHFUNCTION}) ' Option Rule
                    If tok.Type = TokenType.MATHFUNCTION Then
lbProblemSolved =                         ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MATHFUNCTION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: EXPRESSIONPART

        Private Function ParseEXISTSSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: EXISTSSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXISTSSTMT), "EXISTSSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDEXISTS) ' Terminal Rule: KEYWDEXISTS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDEXISTS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDEXISTS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEXISTS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: EXISTSSTMT

        Private Function ParseEXTERNALUNIQUENESSCONSTRAINTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: EXTERNALUNIQUENESSCONSTRAINTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXTERNALUNIQUENESSCONSTRAINTSTMT), "EXTERNALUNIQUENESSCONSTRAINTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFOREACH) ' Terminal Rule: KEYWDFOREACH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFOREACH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFOREACH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFOREACH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear
                        ParseADDITIONALMODELELEMENT(node) ' NonTerminal Rule: ADDITIONALMODELELEMENT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDATMOSTONE) ' Terminal Rule: KEYWDATMOSTONE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDATMOSTONE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTHAT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.PREDICATE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDTHAT Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.MODELELEMENTNAME Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                  lbProblemSolved = False
                                  Return False

                                End If


            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: EXTERNALUNIQUENESSCONSTRAINTSTMT

        Private Function ParseFACTTYPEISWHERESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPEISWHERESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEISWHERESTMT), "FACTTYPEISWHERESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISWHERE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPEISWHERESTMT

        Private Function ParseFACTTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPESTMT), "FACTTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPEIDENTIFICATION(node) ' NonTerminal Rule: FACTTYPEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.MODELELEMENTNAME Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                  lbProblemSolved = False
                                  Return False

                                End If


            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPESTMT

        Private Function ParseFACTTYPEIDENTIFICATION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEIDENTIFICATION), "FACTTYPEIDENTIFICATION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.KEYWDISA}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.PREDICATE
                    lbProblemSolved =                             ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDISA
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDISA) ' Terminal Rule: KEYWDISA
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDISA Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDISA) ' Terminal Rule: KEYWDISA
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDISA Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                              lbProblemSolved = False
                              Return False

                            End If


                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPEIDENTIFICATION

        Private Function ParseFACTTYPEPARTCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPEPARTCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEPARTCLAUSE), "FACTTYPEPARTCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE
            m_tree.Errors.Clear

                 ' Concat Rule
                lbProblemSolved =                         ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If


                 ' Concat Rule
                                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.MODELELEMENTNAME Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                          lbProblemSolved = False
                          Return False

                        End If


            If m_tree.Errors.Count > 0 Then
                      Return False
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            If Not lbProblemSolved Then Exit While
            End While
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPEPARTCLAUSE

        Private Function ParseBINARYFACTTYPECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: BINARYFACTTYPECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BINARYFACTTYPECLAUSE), "BINARYFACTTYPECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDATMOSTONE) ' Terminal Rule: KEYWDATMOSTONE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDATMOSTONE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: BINARYFACTTYPECLAUSE

        Private Function ParseFACTTYPEPRODUCTION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTTYPEPRODUCTION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEPRODUCTION), "FACTTYPEPRODUCTION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDISWRITTENAS, TokenType.KEYWDISIDENTIFIEDBYITS, TokenType.KEYWDISWHERE, TokenType.PREDICATE, TokenType.KEYWDISAKINDOF}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDISWRITTENAS
                    lbProblemSolved =                             ParseVALUETYPEISWRITTENASSTMT(node) ' NonTerminal Rule: VALUETYPEISWRITTENASSTMT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDISIDENTIFIEDBYITS
                    lbProblemSolved =                             ParseENTITYTYPEISIDENTIFIEDBYITSCLAUSE(node) ' NonTerminal Rule: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDISIDENTIFIEDBYITS
                    lbProblemSolved =                             ParseREFERENCEMODECLAUSE(node) ' NonTerminal Rule: REFERENCEMODECLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDISWHERE
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDISWHERE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                            lbProblemSolved =                                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                                    While tok.Type = TokenType.COMMA
                                    m_tree.Errors.Clear

                                         ' Concat Rule
                                                                                        lbProblemSolved = True
                                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                                n = node.CreateNode(tok, tok.ToString() )
                                                node.Token.UpdateRange(tok)
                                                node.Nodes.Add(n)
                                                If tok.Type <> TokenType.COMMA Then
                                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                                  lbProblemSolved = False
                                                  Return False

                                                End If



                                         ' Concat Rule
                                        lbProblemSolved =                                                 ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                              Return False
            End If
                                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                                    If Not lbProblemSolved Then Exit While
                                    End While
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.PREDICATE
                    
                             ' Concat Rule
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.KEYWDATMOSTONE, TokenType.KEYWDONE, TokenType.MODELELEMENTNAME}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.KEYWDATMOSTONE
                                    lbProblemSolved =                                             ParseBINARYFACTTYPECLAUSE(node) ' NonTerminal Rule: BINARYFACTTYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDONE
                                    lbProblemSolved =                                             ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(node) ' NonTerminal Rule: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.MODELELEMENTNAME
                                    
                                             ' Concat Rule
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If



                                             ' Concat Rule
                                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    While tok.Type = TokenType.PREDICATE
                                                    m_tree.Errors.Clear

                                                         ' Concat Rule
                                                        lbProblemSolved =                                                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                                  lbProblemSolved = False
            End If


                                                         ' Concat Rule
                                                                                                                        tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME}) ' Option Rule
                                                                If tok.Type = TokenType.MODELELEMENTNAME Then
                                                                    lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If


                                                                Else
                                                                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                End If
            If m_tree.Errors.Count > 0 Then
                                                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                              Return False
            End If
                                                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    If Not lbProblemSolved Then Exit While
                                                    End While
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                  Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    
                                             ' Concat Rule
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If



                                             ' Concat Rule
                                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    While tok.Type = TokenType.PREDICATE
                                                    m_tree.Errors.Clear

                                                         ' Concat Rule
                                                        lbProblemSolved =                                                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                                  lbProblemSolved = False
            End If


                                                         ' Concat Rule
                                                                                                                        tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME}) ' Option Rule
                                                                If tok.Type = TokenType.MODELELEMENTNAME Then
                                                                    lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If


                                                                Else
                                                                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                End If
            If m_tree.Errors.Count > 0 Then
                                                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                              Return False
            End If
                                                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    If Not lbProblemSolved Then Exit While
                                                    End While
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                  Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISWHERE}) ' Option Rule
                                    If tok.Type = TokenType.KEYWDISWHERE Then
lbProblemSolved =                                         ParseDERIVATIONCLAUSE(node) ' NonTerminal Rule: DERIVATIONCLAUSE
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.KEYWDISAKINDOF
                    lbProblemSolved =                             ParseSUBTYPECLAUSE(node) ' NonTerminal Rule: SUBTYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWRITTENAS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISAKINDOF"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseENTITYTYPEISIDENTIFIEDBYITSCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseREFERENCEMODECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: REFERENCEMODECLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDISWHERE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                            lbProblemSolved =                                     ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                                    While tok.Type = TokenType.COMMA
                                    m_tree.Errors.Clear

                                         ' Concat Rule
                                                                                        lbProblemSolved = True
                                                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                                                n = node.CreateNode(tok, tok.ToString() )
                                                node.Token.UpdateRange(tok)
                                                node.Nodes.Add(n)
                                                If tok.Type <> TokenType.COMMA Then
                                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                                                  lbProblemSolved = False
                                                  Return False

                                                End If



                                         ' Concat Rule
                                        lbProblemSolved =                                                 ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                                              Return False
            End If
                                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                                    If Not lbProblemSolved Then Exit While
                                    End While
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.KEYWDATMOSTONE, TokenType.KEYWDONE, TokenType.MODELELEMENTNAME}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.KEYWDATMOSTONE
                                    lbProblemSolved =                                             ParseBINARYFACTTYPECLAUSE(node) ' NonTerminal Rule: BINARYFACTTYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.KEYWDONE
                                    lbProblemSolved =                                             ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(node) ' NonTerminal Rule: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.MODELELEMENTNAME
                                    
                                             ' Concat Rule
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If



                                             ' Concat Rule
                                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    While tok.Type = TokenType.PREDICATE
                                                    m_tree.Errors.Clear

                                                         ' Concat Rule
                                                        lbProblemSolved =                                                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                                  lbProblemSolved = False
            End If


                                                         ' Concat Rule
                                                                                                                        tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME}) ' Option Rule
                                                                If tok.Type = TokenType.MODELELEMENTNAME Then
                                                                    lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If


                                                                Else
                                                                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                End If
            If m_tree.Errors.Count > 0 Then
                                                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                              Return False
            End If
                                                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    If Not lbProblemSolved Then Exit While
                                                    End While
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                  Return False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONE"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    
                                             ' Concat Rule
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If



                                             ' Concat Rule
                                                                                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    While tok.Type = TokenType.PREDICATE
                                                    m_tree.Errors.Clear

                                                         ' Concat Rule
                                                        lbProblemSolved =                                                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                                  lbProblemSolved = False
            End If


                                                         ' Concat Rule
                                                                                                                        tok = m_scanner.LookAhead({TokenType.MODELELEMENTNAME}) ' Option Rule
                                                                If tok.Type = TokenType.MODELELEMENTNAME Then
                                                                    lbProblemSolved = True
                                                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                                    n = node.CreateNode(tok, tok.ToString() )
                                                                    node.Token.UpdateRange(tok)
                                                                    node.Nodes.Add(n)
                                                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                      lbProblemSolved = False
                                                                      Return False

                                                                    End If


                                                                Else
                                                                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                                End If
            If m_tree.Errors.Count > 0 Then
                                                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                              Return False
            End If
                                                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                                                    If Not lbProblemSolved Then Exit While
                                                    End While
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                                  Return False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISWHERE}) ' Option Rule
                                    If tok.Type = TokenType.KEYWDISWHERE Then
lbProblemSolved =                                         ParseDERIVATIONCLAUSE(node) ' NonTerminal Rule: DERIVATIONCLAUSE
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseSUBTYPECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: SUBTYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTTYPEPRODUCTION

        Private Function ParseFACTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: FACTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTSTMT), "FACTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseNODEPROPERTYNAMEIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYNAMEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                        lbProblemSolved =                                 ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If


                         ' Concat Rule
                        lbProblemSolved =                                 ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: FACTSTMT

        Private Function ParseGETSUPERTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: GETSUPERTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.GETSUPERTYPESTMT), "GETSUPERTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDGET) ' Terminal Rule: KEYWDGET
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDGET Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDGET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDGET"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDSUPERTYPE) ' Terminal Rule: KEYWDSUPERTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDSUPERTYPE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSUPERTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSUPERTYPE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOF) ' Terminal Rule: KEYWDOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOF"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: GETSUPERTYPESTMT

        Private Function ParseINDIVIDUALIDENTIFIER(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: INDIVIDUALIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INDIVIDUALIDENTIFIER), "INDIVIDUALIDENTIFIER")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.NUMBER
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.NUMBER Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                      lbProblemSolved = False
                      Return False

                    End If


                Case TokenType.SINGLEQUOTE
            lbProblemSolved =                     ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseQUOTEDIDENTIFIER(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: INDIVIDUALIDENTIFIER

        Private Function ParseINMODELSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: INMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INMODELSTMT), "INMODELSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDIN) ' Terminal Rule: KEYWDIN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDIN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODEL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELID) ' Terminal Rule: MODELID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELID Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELID"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: INMODELSTMT

        Private Function ParseINSERTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: INSERTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INSERTSTMT), "INSERTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDINSERT) ' Terminal Rule: KEYWDINSERT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDINSERT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINSERT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINSERT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDINTO) ' Terminal Rule: KEYWDINTO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDINTO Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINTO"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.BROPEN}) ' Option Rule
                    If tok.Type = TokenType.BROPEN Then
lbProblemSolved =                         ParseINSERTCOLUMNLIST(node) ' NonTerminal Rule: INSERTCOLUMNLIST
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDON}) ' Option Rule
                    If tok.Type = TokenType.KEYWDON Then
lbProblemSolved =                         ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDIN}) ' Option Rule
                    If tok.Type = TokenType.KEYWDIN Then
lbProblemSolved =                         ParseINMODELSTMT(node) ' NonTerminal Rule: INMODELSTMT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIN"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDVALUES) ' Terminal Rule: KEYWDVALUES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUES Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUES"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUELIST(node) ' NonTerminal Rule: VALUELIST
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: INSERTSTMT

        Private Function ParseITISMANDATORYTHATSTMNT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ITISMANDATORYTHATSTMNT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ITISMANDATORYTHATSTMNT), "ITISMANDATORYTHATSTMNT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDITISMANDATORYTHAT) ' Terminal Rule: KEYWDITISMANDATORYTHAT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDITISMANDATORYTHAT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDITISMANDATORYTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDITISMANDATORYTHAT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseFACTREADING(node) ' NonTerminal Rule: FACTREADING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ITISMANDATORYTHATSTMNT

        Private Function ParseLISTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: LISTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.LISTSTMT), "LISTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDLIST) ' Terminal Rule: KEYWDLIST
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDLIST Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLIST.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLIST"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMODELELEMENTPLURAL(node) ' NonTerminal Rule: MODELELEMENTPLURAL
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: LISTSTMT

        Private Function ParseMATCHFACTTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MATCHFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHFACTTYPESTMT), "MATCHFACTTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMATCH) ' Terminal Rule: KEYWDMATCH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMATCH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMATCH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseSETCLAUSE(node) ' NonTerminal Rule: SETCLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MATCHFACTTYPESTMT

        Private Function ParseMATCHSELECTSETFACTTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MATCHSELECTSETFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHSELECTSETFACTTYPESTMT), "MATCHSELECTSETFACTTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMATCH) ' Terminal Rule: KEYWDMATCH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMATCH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMATCH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseSETCLAUSE(node) ' NonTerminal Rule: SETCLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MATCHSELECTSETFACTTYPESTMT

        Private Function ParseMATHCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MATHCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATHCLAUSE), "MATHCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MATHFUNCTION) ' Terminal Rule: MATHFUNCTION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MATHFUNCTION Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MATHFUNCTION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.NUMBER
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.NUMBER Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                              lbProblemSolved = False
                              Return False

                            End If


                        Case TokenType.PREBOUNDREADINGTEXT
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseMODELELEMENT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.EXPRESSIONSYMBOL) ' ZeroOrMore Rule
                    While tok.Type = TokenType.EXPRESSIONSYMBOL
                    m_tree.Errors.Clear
                        ParseEXPRESSION(node) ' NonTerminal Rule: EXPRESSION
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.EXPRESSIONSYMBOL) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MATHCLAUSE

        Private Function ParseMATCHSELECTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: MATCHSELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHSELECTSTMT), "MATCHSELECTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMATCH) ' Terminal Rule: KEYWDMATCH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMATCH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMATCH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDSET, TokenType.KEYWDRETURN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDSET
                    lbProblemSolved =                             ParseSETCLAUSE(node) ' NonTerminal Rule: SETCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDRETURN
                    lbProblemSolved =                             ParseRETURNCLAUSE(node) ' NonTerminal Rule: RETURNCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSET"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRETURN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseRETURNCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: RETURNCLAUSE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: MATCHSELECTSTMT

        Private Function ParseONPAGESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: ONPAGESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ONPAGESTMT), "ONPAGESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDON) ' Terminal Rule: KEYWDON
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDON Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDPAGE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PAGENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.SINGLEQUOTE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: ONPAGESTMT

        Private Function ParseOPENMODELSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: OPENMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.OPENMODELSTMT), "OPENMODELSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDOPEN) ' Terminal Rule: KEYWDOPEN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDOPEN Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOPEN"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODEL Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELNAME) ' Terminal Rule: MODELNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: OPENMODELSTMT

        Private Function ParsePREDICATENODEPROPERTYIDENTIFICATION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: PREDICATENODEPROPERTYIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PREDICATENODEPROPERTYIDENTIFICATION), "PREDICATENODEPROPERTYIDENTIFICATION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: PREDICATENODEPROPERTYIDENTIFICATION

        Private Function ParseSELECTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: SELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SELECTSTMT), "SELECTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDSELECT) ' Terminal Rule: KEYWDSELECT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDSELECT Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSELECT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSELECT"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDDISTINCT}) ' Option Rule
                    If tok.Type = TokenType.KEYWDDISTINCT Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.KEYWDDISTINCT) ' Terminal Rule: KEYWDDISTINCT
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDDISTINCT Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDISTINCT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDISTINCT"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDISTINCT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDISTINCT"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNLIST(node) ' NonTerminal Rule: COLUMNLIST
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFROM Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDON}) ' Option Rule
                    If tok.Type = TokenType.KEYWDON Then
lbProblemSolved =                         ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDWHERE}) ' Option Rule
                    If tok.Type = TokenType.KEYWDWHERE Then
lbProblemSolved =                         ParseWHERESTMT(node) ' NonTerminal Rule: WHERESTMT
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: SELECTSTMT

        Private Function ParseSHOWSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: SHOWSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SHOWSTMT), "SHOWSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDSHOW) ' Terminal Rule: KEYWDSHOW
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDSHOW Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSHOW.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHOW"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: SHOWSTMT

        Private Function ParseSUBTYPECLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: SUBTYPECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SUBTYPECLAUSE), "SUBTYPECLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISAKINDOF) ' Terminal Rule: KEYWDISAKINDOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISAKINDOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISAKINDOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISAKINDOF"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: SUBTYPECLAUSE

        Private Function ParseSUBTYPESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: SUBTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SUBTYPESTMT), "SUBTYPESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
            lbProblemSolved =                     ParseFACTTYPEIDENTIFICATION(node) ' NonTerminal Rule: FACTTYPEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: SUBTYPESTMT

        Private Function ParseTABLEIDENTIFICATION(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: TABLEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.TABLEIDENTIFICATION), "TABLEIDENTIFICATION")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.BROPEN}) ' Option Rule
                    If tok.Type = TokenType.BROPEN Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.BROPEN Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.BRCLOSE}) ' Option Rule
                    If tok.Type = TokenType.BRCLOSE Then
                        lbProblemSolved = True
                        tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.BRCLOSE Then
                          m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                          lbProblemSolved = False
                          Return False

                        End If


                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    While tok.Type = TokenType.PREDICATE
                    m_tree.Errors.Clear

                         ' Concat Rule
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.PREDICATE Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                  lbProblemSolved = False
                                  Return False

                                End If



                         ' Concat Rule
                                                        tok = m_scanner.LookAhead({TokenType.BROPEN, TokenType.KEYWDWHICH}) ' Choice Rule
                                Select Case tok.Type
                                 ' Choice Rule
                                    Case TokenType.BROPEN
                                lbProblemSolved =                                         ParseNODEIDENTIFICATION(node) ' NonTerminal Rule: NODEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Case TokenType.KEYWDWHICH
                                
                                         ' Concat Rule
                                                                                        lbProblemSolved = True
                                                tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                n = node.CreateNode(tok, tok.ToString() )
                                                node.Token.UpdateRange(tok)
                                                node.Nodes.Add(n)
                                                If tok.Type <> TokenType.KEYWDWHICH Then
                                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                  lbProblemSolved = False
                                                  Return False

                                                End If



                                         ' Concat Rule
                                                                                        lbProblemSolved = True
                                                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                n = node.CreateNode(tok, tok.ToString() )
                                                node.Token.UpdateRange(tok)
                                                node.Nodes.Add(n)
                                                If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                  lbProblemSolved = False
                                                  Return False

                                                End If


            If m_tree.Errors.Count > 0 Then
                                              Return False
            End If

                                    Case Else
                                    If m_tree.Errors.Count = 0 Then
                                    m_tree.Optionals.Clear
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                    End If
                                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                        Exit Select
                                End Select ' Choice Rule
                                    If Not lbProblemSolved Then
                                       m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                
                                         ' Concat Rule
                                                                                        lbProblemSolved = True
                                                tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                n = node.CreateNode(tok, tok.ToString() )
                                                node.Token.UpdateRange(tok)
                                                node.Nodes.Add(n)
                                                If tok.Type <> TokenType.KEYWDWHICH Then
                                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                  lbProblemSolved = False
                                                  Return False

                                                End If



                                         ' Concat Rule
                                                                                        lbProblemSolved = True
                                                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                                n = node.CreateNode(tok, tok.ToString() )
                                                node.Token.UpdateRange(tok)
                                                node.Nodes.Add(n)
                                                If tok.Type <> TokenType.MODELELEMENTNAME Then
                                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                  lbProblemSolved = False
                                                  Return False

                                                End If


            If m_tree.Errors.Count > 0 Then
                                              Return False
            End If

                                    End If
            If m_tree.Errors.Count > 0 Then
                                            Return False
            End If

            If m_tree.Errors.Count > 0 Then
                              Return False
            End If
                    tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: TABLEIDENTIFICATION

        Private Function ParseUPDATESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: UPDATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.UPDATESTMT), "UPDATESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDUPDATE) ' Terminal Rule: KEYWDUPDATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDUPDATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDUPDATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDUPDATE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDSET) ' Terminal Rule: KEYWDSET
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDSET Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSET"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EQUALS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWHERE) ' Terminal Rule: KEYWDWHERE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWHERE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EQUALS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: UPDATESTMT

        Private Function ParseVALUETYPEISWRITTENASSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: VALUETYPEISWRITTENASSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.VALUETYPEISWRITTENASSTMT), "VALUETYPEISWRITTENASSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDISWRITTENAS) ' Terminal Rule: KEYWDISWRITTENAS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISWRITTENAS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWRITTENAS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDDATATYPELOGICALTRUEFALSE, TokenType.KEYWDDATATYPELOGICALYESNO, TokenType.KEYWDDATATYPEAUTOCOUNTER, TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION, TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION, TokenType.KEYWDDATATYPESIGNEDBIGINTEGER, TokenType.KEYWDDATATYPESIGNEDINTEGER, TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER, TokenType.KEYWDDATATYPEOBJECTID, TokenType.KEYWDDATATYPEROWID, TokenType.KEYWDDATATYPERAWDATAOLEOBJECT, TokenType.KEYWDDATATYPERAWDATA, TokenType.KEYWDDATATYPEAUTOTIMESTAMP, TokenType.KEYWDDATATYPEDATE, TokenType.KEYWDDATATYPEDATETIME, TokenType.KEYWDDATATYPETIME, TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH, TokenType.KEYWDDATATYPERAWDATALARGELENGTH, TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH, TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH, TokenType.KEYWDDATATYPESTRINGLARGELENGTH, TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH, TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION, TokenType.KEYWDDATATYPEDECIMAL, TokenType.KEYWDDATATYPEMONEY}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDDATATYPELOGICALTRUEFALSE
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPELOGICALYESNO
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEAUTOCOUNTER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESIGNEDBIGINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESIGNEDINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEOBJECTID
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEROWID
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATAOLEOBJECT
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATA
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEAUTOTIMESTAMP
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEDATE
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEDATETIME
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPETIME
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATALARGELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESTRINGLARGELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION
                    lbProblemSolved =                             ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEDECIMAL
                    lbProblemSolved =                             ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEMONEY
                    lbProblemSolved =                             ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseDATATYPELENGTH(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseDATATYPEPRECISION(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: VALUETYPEISWRITTENASSTMT

        Private Function ParseWHERESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WHERESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHERESTMT), "WHERESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWHERE) ' Terminal Rule: KEYWDWHERE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWHERE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND
                    m_tree.Errors.Clear
                        ParseADDITIONALCOMPARISON(node) ' NonTerminal Rule: ADDITIONALCOMPARISON
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WHERESTMT

        Private Function ParseWHICHTHATCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WHICHTHATCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHICHTHATCLAUSE), "WHICHTHATCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDIS
                                tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDIS
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDIS Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.PREDICATE
                    
                             ' Concat Rule
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.OPENSQUAREBRACKET}) ' Option Rule
                                    If tok.Type = TokenType.OPENSQUAREBRACKET Then
lbProblemSolved =                                         ParseRECURSIVECLAUSE(node) ' NonTerminal Rule: RECURSIVECLAUSE
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUAREBRACKET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENSQUAREBRACKET"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.OPENSQUAREBRACKET}) ' Option Rule
                                    If tok.Type = TokenType.OPENSQUAREBRACKET Then
lbProblemSolved =                                         ParseRECURSIVECLAUSE(node) ' NonTerminal Rule: RECURSIVECLAUSE
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUAREBRACKET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENSQUAREBRACKET"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

                Case TokenType.PREDICATE
                                tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDIS
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDIS Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.PREDICATE Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.PREDICATE
                    
                             ' Concat Rule
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.OPENSQUAREBRACKET}) ' Option Rule
                                    If tok.Type = TokenType.OPENSQUAREBRACKET Then
lbProblemSolved =                                         ParseRECURSIVECLAUSE(node) ' NonTerminal Rule: RECURSIVECLAUSE
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUAREBRACKET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENSQUAREBRACKET"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    
                             ' Concat Rule
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If


                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.OPENSQUAREBRACKET}) ' Option Rule
                                    If tok.Type = TokenType.OPENSQUAREBRACKET Then
lbProblemSolved =                                         ParseRECURSIVECLAUSE(node) ' NonTerminal Rule: RECURSIVECLAUSE
            If m_tree.Errors.Count > 0 Then
                                          lbProblemSolved = False
            End If

                                    Else
                                                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUAREBRACKET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "OPENSQUAREBRACKET"))
                                    End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

                Case TokenType.KEYWDTHAT
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDTHAT Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.PREDICATE
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                Case TokenType.PREBOUNDREADINGTEXT
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDISNOT
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.KEYWDIS
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.PREDICATE
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case TokenType.MODELELEMENTNAME
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDISNOT
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.KEYWDIS
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.PREDICATE
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDISNOT
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.KEYWDIS
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.PREDICATE
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case TokenType.PREBOUNDREADINGTEXT
            
                     ' Concat Rule
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.EXPRESSIONSYMBOL, TokenType.PREDICATE}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.EXPRESSIONSYMBOL
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.EXPRESSIONSYMBOL) ' Terminal Rule: EXPRESSIONSYMBOL
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.EXPRESSIONSYMBOL Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case TokenType.PREDICATE
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case TokenType.MODELELEMENTNAME
            
                     ' Concat Rule
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.EXPRESSIONSYMBOL, TokenType.PREDICATE}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.EXPRESSIONSYMBOL
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.EXPRESSIONSYMBOL) ' Terminal Rule: EXPRESSIONSYMBOL
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.EXPRESSIONSYMBOL Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case TokenType.PREDICATE
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            
                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDTHAT Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                              lbProblemSolved = False
                              Return False

                            End If



                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.PREDICATE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.PREDICATE
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                Case TokenType.PREBOUNDREADINGTEXT
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDISNOT
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.KEYWDIS
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.PREDICATE
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case TokenType.MODELELEMENTNAME
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDISNOT
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.KEYWDIS
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.PREDICATE
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            
                                     ' Concat Rule
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If


                                     ' Concat Rule
                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDISNOT
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.KEYWDIS
                                                                                                tok = m_scanner.LookAhead({TokenType.KEYWDISNOT, TokenType.KEYWDIS}) ' Choice Rule
                                                    Select Case tok.Type
                                                     ' Choice Rule
                                                        Case TokenType.KEYWDISNOT
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case TokenType.KEYWDIS
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        Case Else
                                                        If m_tree.Errors.Count = 0 Then
                                                        m_tree.Optionals.Clear
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                        End If
                                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                            Exit Select
                                                    End Select ' Choice Rule
                                                        If Not lbProblemSolved Then
                                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                                lbProblemSolved = True
                                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                                            n = node.CreateNode(tok, tok.ToString() )
                                                            node.Token.UpdateRange(tok)
                                                            node.Nodes.Add(n)
                                                            If tok.Type <> TokenType.KEYWDIS Then
                                                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                              lbProblemSolved = False
                                                              Return False

                                                            End If


                                                        End If
            If m_tree.Errors.Count > 0 Then
                                                                Return False
            End If

                                                Case TokenType.PREDICATE
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                          Return False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            
                     ' Concat Rule
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                tok = m_scanner.LookAhead({TokenType.EXPRESSIONSYMBOL, TokenType.PREDICATE}) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.EXPRESSIONSYMBOL
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.EXPRESSIONSYMBOL) ' Terminal Rule: EXPRESSIONSYMBOL
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.EXPRESSIONSYMBOL Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                                      lbProblemSolved = False
                                      Return False

                                    End If


                                Case TokenType.PREDICATE
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
                                If Not lbProblemSolved Then
                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                            lbProblemSolved =                                     ParsePREDICATECLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                      lbProblemSolved = False
            End If

                                End If
            If m_tree.Errors.Count > 0 Then
                                        Return False
            End If

            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WHICHTHATCLAUSE

        Private Function ParseWHICHCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WHICHCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHICHCLAUSE), "WHICHCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDAND, TokenType.KEYWDWHICH}) ' Option Rule
                    If tok.Type = TokenType.KEYWDAND Or tok.Type = TokenType.KEYWDWHICH Then
                        tok = m_scanner.LookAhead({TokenType.KEYWDAND, TokenType.KEYWDWHICH}) ' Choice Rule
                        Select Case tok.Type
                         ' Choice Rule
                            Case TokenType.KEYWDAND
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDAND Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            Case TokenType.KEYWDWHICH
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDWHICH Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            Case Else
                            If m_tree.Errors.Count = 0 Then
                            m_tree.Optionals.Clear
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                            End If
                                m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                Exit Select
                        End Select ' Choice Rule
                            If Not lbProblemSolved Then
                               m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDWHICH Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            End If
            If m_tree.Errors.Count > 0 Then
                                    Return False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDWHICH, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                    If tok.Type = TokenType.KEYWDWITH Or tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Or tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.BROPEN Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                        tok = m_scanner.LookAhead({TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDWHICH, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                        Select Case tok.Type
                         ' Choice Rule
                            Case TokenType.KEYWDWITH
                        lbProblemSolved =                                 ParseWITHCLAUSE(node) ' NonTerminal Rule: WITHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                  lbProblemSolved = False
            End If

                            Case TokenType.KEYWDIS
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.PREDICATE
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.KEYWDTHAT
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.PREBOUNDREADINGTEXT
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.MODELELEMENTNAME
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.KEYWDWHICH
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.KEYWDAN
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.KEYWDA
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.KEYWDNO
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.KEYWDCOUNT
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.NUMBER
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.SINGLEQUOTE
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.BROPEN
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.FOLLOWINGREADINGTEXT
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case TokenType.MATHFUNCTION
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            Case Else
                            If m_tree.Errors.Count = 0 Then
                            m_tree.Optionals.Clear
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                            End If
                                m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                Exit Select
                        End Select ' Choice Rule
                            If Not lbProblemSolved Then
                               m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                        
                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
lbProblemSolved =                                             ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Option Rule
                                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Then
                                            tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.KEYWDWHICH
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDTHAT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDAN
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDA
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDNO
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.KEYWDCOUNT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDAN Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDA Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDNO) ' Terminal Rule: KEYWDNO
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDNO Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNO"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Option Rule
                                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                                            tok = m_scanner.LookAhead({TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.NUMBER
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.SINGLEQUOTE
                                            lbProblemSolved =                                                     ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.PREBOUNDREADINGTEXT
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.MODELELEMENTNAME
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case TokenType.BROPEN
                                            lbProblemSolved =                                                     ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseNODE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If


                                 ' Concat Rule
                                                                        tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Option Rule
                                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                                            tok = m_scanner.LookAhead({TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION}) ' Choice Rule
                                            Select Case tok.Type
                                             ' Choice Rule
                                                Case TokenType.FOLLOWINGREADINGTEXT
                                                                                                lbProblemSolved = True
                                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                                    n = node.CreateNode(tok, tok.ToString() )
                                                    node.Token.UpdateRange(tok)
                                                    node.Nodes.Add(n)
                                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                      lbProblemSolved = False
                                                      Return False

                                                    End If


                                                Case TokenType.MATHFUNCTION
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                Case Else
                                                If m_tree.Errors.Count = 0 Then
                                                m_tree.Optionals.Clear
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                                End If
                                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                                    Exit Select
                                            End Select ' Choice Rule
                                                If Not lbProblemSolved Then
                                                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                            lbProblemSolved =                                                     ParseMATHCLAUSE(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                      lbProblemSolved = False
            End If

                                                End If
            If m_tree.Errors.Count > 0 Then
                                                        Return False
            End If

                                        Else
                                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        End If
            If m_tree.Errors.Count > 0 Then
                                                    Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                      Return False
            End If

                            End If
            If m_tree.Errors.Count > 0 Then
                                    Return False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WHICHCLAUSE

        Private Function ParseWITHCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WITHCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WITHCLAUSE), "WITHCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWITH) ' Terminal Rule: KEYWDWITH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWITH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDWHAT, TokenType.KEYWDA}) ' Option Rule
                    If tok.Type = TokenType.KEYWDWHAT Or tok.Type = TokenType.KEYWDA Then
                        tok = m_scanner.LookAhead({TokenType.KEYWDWHAT, TokenType.KEYWDA}) ' Choice Rule
                        Select Case tok.Type
                         ' Choice Rule
                            Case TokenType.KEYWDWHAT
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDWHAT) ' Terminal Rule: KEYWDWHAT
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDWHAT Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHAT"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            Case TokenType.KEYWDA
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            Case Else
                            If m_tree.Errors.Count = 0 Then
                            m_tree.Optionals.Clear
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHAT"))
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                            End If
                                m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                Exit Select
                        End Select ' Choice Rule
                            If Not lbProblemSolved Then
                               m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                                        lbProblemSolved = True
                                tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                n = node.CreateNode(tok, tok.ToString() )
                                node.Token.UpdateRange(tok)
                                node.Nodes.Add(n)
                                If tok.Type <> TokenType.KEYWDA Then
                                  m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                  lbProblemSolved = False
                                  Return False

                                End If


                            End If
            If m_tree.Errors.Count > 0 Then
                                    Return False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHAT"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.PREBOUNDREADINGTEXT
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.MODELELEMENTNAME
                    lbProblemSolved =                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.BROPEN
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WITHCLAUSE

        Private Function ParseWHICHSELECTSTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WHICHSELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHICHSELECTSTMT), "WHICHSELECTSTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDWHICH, TokenType.BROPEN}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDWHICH
                    
                             ' Concat Rule
                                                                lbProblemSolved = True
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                      lbProblemSolved = False
                                      Return False

                                    End If



                             ' Concat Rule
                                                                tok = m_scanner.LookAhead({TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN}) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.PREBOUNDREADINGTEXT
                                    lbProblemSolved =                                             ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.BROPEN
                                    lbProblemSolved =                                             ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.PREBOUNDREADINGTEXT
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case TokenType.MODELELEMENTNAME
                                    lbProblemSolved =                                             ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
                                        If Not lbProblemSolved Then
                                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                                    lbProblemSolved =                                             ParseMODELELEMENT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                              lbProblemSolved = False
            End If

                                        End If
            If m_tree.Errors.Count > 0 Then
                                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                                  Return False
            End If

                        Case TokenType.BROPEN
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseNODEPROPERTYIDENTIFICATION(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
                    While tok.Type = TokenType.KEYWDAND Or tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDWITH Or tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDNO Or tok.Type = TokenType.KEYWDCOUNT Or tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.BROPEN Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION
                    m_tree.Errors.Clear
                        ParseWHICHCLAUSE(node) ' NonTerminal Rule: WHICHCLAUSE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If
                    tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDNO, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
                    If Not lbProblemSolved Then Exit While
                    End While
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDRETURN}) ' Option Rule
                    If tok.Type = TokenType.KEYWDRETURN Then
lbProblemSolved =                         ParseRETURNCLAUSE(node) ' NonTerminal Rule: RETURNCLAUSE
            If m_tree.Errors.Count > 0 Then
                          lbProblemSolved = False
            End If

                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRETURN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRETURN"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                      lbProblemSolved = False
                      Return False

                    End If


            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WHICHSELECTSTMT

        Private Function ParseWITHPREDICATESTMT(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WITHPREDICATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WITHPREDICATESTMT), "WITHPREDICATESTMT")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWITH) ' Terminal Rule: KEYWDWITH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWITH Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDPREDICATE) ' Terminal Rule: KEYWDPREDICATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDPREDICATE Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPREDICATE"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
            lbProblemSolved =                     ParseBRACKTEDCOLMNLIST(node) ' NonTerminal Rule: BRACKTEDCOLMNLIST
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If


             ' Concat Rule
            lbProblemSolved =                     ParseVALUELIST(node) ' NonTerminal Rule: VALUELIST
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WITHPREDICATESTMT

        Private Function ParseWRITTENASCLAUSE(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: WRITTENASCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WRITTENASCLAUSE), "WRITTENASCLAUSE")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)


             ' Concat Rule
                                lbProblemSolved = True
                    tok = m_scanner.Scan(TokenType.KEYWDWRITTENAS) ' Terminal Rule: KEYWDWRITTENAS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDWRITTENAS Then
                      m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWRITTENAS"))
                      lbProblemSolved = False
                      Return False

                    End If



             ' Concat Rule
                                tok = m_scanner.LookAhead({TokenType.KEYWDDATATYPELOGICALTRUEFALSE, TokenType.KEYWDDATATYPELOGICALYESNO, TokenType.KEYWDDATATYPEAUTOCOUNTER, TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION, TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION, TokenType.KEYWDDATATYPESIGNEDBIGINTEGER, TokenType.KEYWDDATATYPESIGNEDINTEGER, TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER, TokenType.KEYWDDATATYPEOBJECTID, TokenType.KEYWDDATATYPEROWID, TokenType.KEYWDDATATYPERAWDATAOLEOBJECT, TokenType.KEYWDDATATYPERAWDATA, TokenType.KEYWDDATATYPEAUTOTIMESTAMP, TokenType.KEYWDDATATYPEDATE, TokenType.KEYWDDATATYPEDATETIME, TokenType.KEYWDDATATYPETIME, TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH, TokenType.KEYWDDATATYPERAWDATALARGELENGTH, TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH, TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH, TokenType.KEYWDDATATYPESTRINGLARGELENGTH, TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH, TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION, TokenType.KEYWDDATATYPEDECIMAL, TokenType.KEYWDDATATYPEMONEY}) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDDATATYPELOGICALTRUEFALSE
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPELOGICALYESNO
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEAUTOCOUNTER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESIGNEDBIGINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESIGNEDINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEOBJECTID
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEROWID
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATAOLEOBJECT
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATA
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEAUTOTIMESTAMP
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEDATE
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEDATETIME
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPETIME
                    lbProblemSolved =                             ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATALARGELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESTRINGLARGELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH
                    lbProblemSolved =                             ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION
                    lbProblemSolved =                             ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEDECIMAL
                    lbProblemSolved =                             ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case TokenType.KEYWDDATATYPEMONEY
                    lbProblemSolved =                             ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseDATATYPELENGTH(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
                        If Not lbProblemSolved Then
                           m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
                    lbProblemSolved =                             ParseDATATYPEPRECISION(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If

                        End If
            If m_tree.Errors.Count > 0 Then
                                Return False
            End If

            If m_tree.Errors.Count > 0 Then
                  Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: WRITTENASCLAUSE

        Private Function ParseStart(ByVal parent As ParseNode) As Boolean ' NonTerminalSymbol: Start
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.Start), "Start")
            Dim lbProblemSolved As Boolean = True

            Dim liOriginalRange as Integer = m_scanner.StartPos
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead({TokenType.KEYWDCONNECTTOMODEL, TokenType.KEYWDADDFACT, TokenType.KEYWDASSERT, TokenType.KEYWDDATABASE, TokenType.KEYWDCREATE, TokenType.KEYWDDELETE, TokenType.KEYWDDELETEALL, TokenType.KEYWDDELETEFACT, TokenType.KEYWDDESCRIBE, TokenType.KEYWDDID, TokenType.KEYWDSHOW, TokenType.KEYWDEACH, TokenType.KEYWDEITHER, TokenType.KEYWDA, TokenType.KEYWDAN, TokenType.KEYWDENUMERATE, TokenType.KEYWDMATCH, TokenType.KEYWDWHICH, TokenType.BROPEN, TokenType.MODELELEMENTNAME}) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDCONNECTTOMODEL
            lbProblemSolved =                     ParseCONNECTTOMODELSTMT(node) ' NonTerminal Rule: CONNECTTOMODELSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDADDFACT
            lbProblemSolved =                     ParseADDFACTSTMT(node) ' NonTerminal Rule: ADDFACTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDASSERT
            lbProblemSolved =                     ParseASSERTSTMT(node) ' NonTerminal Rule: ASSERTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDDATABASE
            lbProblemSolved =                     ParseCREATEDATABASESTMT(node) ' NonTerminal Rule: CREATEDATABASESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDCREATE
            lbProblemSolved =                     ParseCREATESTMT(node) ' NonTerminal Rule: CREATESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDDELETE
            lbProblemSolved =                     ParseDELETESTMT(node) ' NonTerminal Rule: DELETESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDDELETEALL
            lbProblemSolved =                     ParseDELETEALLSTMT(node) ' NonTerminal Rule: DELETEALLSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDDELETEFACT
            lbProblemSolved =                     ParseDELETEFACTSTMT(node) ' NonTerminal Rule: DELETEFACTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDDESCRIBE
            lbProblemSolved =                     ParseDESCRIBESTMT(node) ' NonTerminal Rule: DESCRIBESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDDID
            lbProblemSolved =                     ParseDIDSELECTSTMT(node) ' NonTerminal Rule: DIDSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDSHOW
            lbProblemSolved =                     ParseSHOWSTMT(node) ' NonTerminal Rule: SHOWSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDEACH
            lbProblemSolved =                     ParseCONSTRAINTEXTERNALSTMT(node) ' NonTerminal Rule: CONSTRAINTEXTERNALSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDEITHER
            lbProblemSolved =                     ParseCONSTRAINTEITHEROR(node) ' NonTerminal Rule: CONSTRAINTEITHEROR
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDA
            lbProblemSolved =                     ParseDERIVEDFACTTYPESTMT(node) ' NonTerminal Rule: DERIVEDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDAN
            lbProblemSolved =                     ParseDERIVEDFACTTYPESTMT(node) ' NonTerminal Rule: DERIVEDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDENUMERATE
            lbProblemSolved =                     ParseENUMERATESTMT(node) ' NonTerminal Rule: ENUMERATESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDMATCH
            lbProblemSolved =                     ParseMATCHSELECTSTMT(node) ' NonTerminal Rule: MATCHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.KEYWDWHICH
            lbProblemSolved =                     ParseWHICHSELECTSTMT(node) ' NonTerminal Rule: WHICHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.BROPEN
            lbProblemSolved =                     ParseWHICHSELECTSTMT(node) ' NonTerminal Rule: WHICHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                Case TokenType.MODELELEMENTNAME
            
                     ' Concat Rule
                    lbProblemSolved =                             ParseFACTTYPEPRODUCTION(node) ' NonTerminal Rule: FACTTYPEPRODUCTION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.EOF Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                              lbProblemSolved = False
                              Return False

                            End If


            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCONNECTTOMODEL"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADDFACT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDASSERT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATABASE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEALL"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEFACT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDESCRIBE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHOW"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEACH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEITHER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENUMERATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCONNECTTOMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseADDFACTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ADDFACTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseASSERTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ASSERTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseCREATEDATABASESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATEDATABASESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseCREATESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CREATESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDELETESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DELETESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDELETEALLSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DELETEALLSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDELETEFACTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DELETEFACTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDESCRIBESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DESCRIBESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDIDSELECTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DIDSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseSHOWSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: SHOWSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseCONSTRAINTEXTERNALSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CONSTRAINTEXTERNALSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseCONSTRAINTEITHEROR(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: CONSTRAINTEITHEROR
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseDERIVEDFACTTYPESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: DERIVEDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseENUMERATESTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: ENUMERATESTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseMATCHSELECTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: MATCHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            lbProblemSolved =                     ParseWHICHSELECTSTMT(parent.Nodes(parent.Nodes.Count -1)) ' NonTerminal Rule: WHICHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                      lbProblemSolved = False
            End If

                End If
                If Not lbProblemSolved Then
                   m_tree.Errors.Clear
              m_scanner.StartPos = liOriginalRange
              node.Nodes.RemoveAt(node.Nodes.Count -1)
            
                     ' Concat Rule
                    lbProblemSolved =                             ParseFACTTYPEPRODUCTION(node) ' NonTerminal Rule: FACTTYPEPRODUCTION
            If m_tree.Errors.Count > 0 Then
                              lbProblemSolved = False
            End If


                     ' Concat Rule
                                                lbProblemSolved = True
                            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.EOF Then
                              m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                              lbProblemSolved = False
                              Return False

                            End If


            If m_tree.Errors.Count > 0 Then
                          Return False
            End If

                End If
            If m_tree.Errors.Count > 0 Then
                        Return False
            End If

            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
            If lbProblemSolved Then
              parent.Token.UpdateRange(node.Token)
            Else
              m_scanner.StartPos = liOriginalRange
              parent.Nodes.Remove(node)
            End If
            Return lbProblemSolved
        End Function ' NonTerminalSymbol: Start


    End Class
#End Region
End Namespace

