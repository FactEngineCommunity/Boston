' Generated by TinyPG v1.3 available at www.codeproject.com

Imports System
Imports System.Collections.Generic


Namespace FEQL
#Region "Parser"

    Partial Public Class Parser 
        Private m_scanner As Scanner
        Private m_tree As ParseTree

        Public Sub New(ByRef scanner As Scanner)
            m_scanner = scanner
        End Sub


    Public Function Parse(ByVal input As String) As ParseTree
            m_tree = New ParseTree()
            Return Parse(input, m_tree)
        End Function

        Public Function Parse(ByVal input As String, ByVal tree As ParseTree) As ParseTree
            m_scanner.Init(input)

            m_tree = tree
            ParseStart(m_tree)
            m_tree.Skipped = m_scanner.Skipped

            Return m_tree
        End Function

        Private Sub ParseAtom(ByVal parent As ParseNode) ' NonTerminalSymbol: Atom
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.Atom), "Atom")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.USERTABLENAME, TokenType.VALUE) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.USERTABLENAME
                    tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.USERTABLENAME Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.VALUE
                    tok = m_scanner.Scan(TokenType.VALUE) ' Terminal Rule: VALUE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.VALUE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VALUE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "VALUE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "VALUE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: Atom

        Private Sub ParseADDITIONALMODELELEMENT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDITIONALMODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALMODELELEMENT), "ADDITIONALMODELELEMENT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDAND Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDITIONALMODELELEMENT

        Private Sub ParseADDITIONALCOLUMNNAME(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDITIONALCOLUMNNAME
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALCOLUMNNAME), "ADDITIONALCOLUMNNAME")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDITIONALCOLUMNNAME

        Private Sub ParseADDITIONALCOMPARISON(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDITIONALCOMPARISON
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALCOMPARISON), "ADDITIONALCOMPARISON")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDAND Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDITIONALCOMPARISON

        Private Sub ParseADDITIONALQUOTEDIDENTIFIER(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDITIONALQUOTEDIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALQUOTEDIDENTIFIER), "ADDITIONALQUOTEDIDENTIFIER")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDITIONALQUOTEDIDENTIFIER

        Private Sub ParseADDITIONALVALUE(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDITIONALVALUE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDITIONALVALUE), "ADDITIONALVALUE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDITIONALVALUE

        Private Sub ParseBRACKTEDCOLMNLIST(ByVal parent As ParseNode) ' NonTerminalSymbol: BRACKTEDCOLMNLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BRACKTEDCOLMNLIST), "BRACKTEDCOLMNLIST")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOLUMNLIST(node) ' NonTerminal Rule: COLUMNLIST
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: BRACKTEDCOLMNLIST

        Private Sub ParseCOLUMNLIST(ByVal parent As ParseNode) ' NonTerminalSymbol: COLUMNLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COLUMNLIST), "COLUMNLIST")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA
                ParseADDITIONALCOLUMNNAME(node) ' NonTerminal Rule: ADDITIONALCOLUMNNAME
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: COLUMNLIST

        Private Sub ParseCOLUMNNAME(ByVal parent As ParseNode) ' NonTerminalSymbol: COLUMNNAME
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COLUMNNAME), "COLUMNNAME")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.STAR, TokenType.COLUMNNAMESTR, TokenType.KEYWDCOUNTSTAR) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.STAR
                    tok = m_scanner.LookAhead(TokenType.STAR) ' Option Rule
                    If tok.Type = TokenType.STAR Then
                        tok = m_scanner.Scan(TokenType.STAR) ' Terminal Rule: STAR
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.STAR Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.COLUMNNAMESTR
                    tok = m_scanner.Scan(TokenType.COLUMNNAMESTR) ' Terminal Rule: COLUMNNAMESTR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLUMNNAMESTR Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDCOUNTSTAR
                    tok = m_scanner.Scan(TokenType.KEYWDCOUNTSTAR) ' Terminal Rule: KEYWDCOUNTSTAR
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDCOUNTSTAR Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNTSTAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "STAR"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLUMNNAMESTR"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNTSTAR"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: COLUMNNAME

        Private Sub ParseCOMPARISON(ByVal parent As ParseNode) ' NonTerminalSymbol: COMPARISON
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COMPARISON), "COMPARISON")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.WHERECLAUSECOLUMNNAMESTR) ' Terminal Rule: WHERECLAUSECOLUMNNAMESTR
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.WHERECLAUSECOLUMNNAMESTR Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHERECLAUSECOLUMNNAMESTR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "WHERECLAUSECOLUMNNAMESTR"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EQUALS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: COMPARISON

        Private Sub ParseCOMPARISONLIST(ByVal parent As ParseNode) ' NonTerminalSymbol: COMPARISONLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.COMPARISONLIST), "COMPARISONLIST")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseADDITIONALCOMPARISON(node) ' NonTerminal Rule: ADDITIONALCOMPARISON
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: COMPARISONLIST

        Private Sub ParseDATATYPE(ByVal parent As ParseNode) ' NonTerminalSymbol: DATATYPE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATATYPE), "DATATYPE")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.KEYWDDATATYPELOGICALTRUEFALSE, TokenType.KEYWDDATATYPELOGICALYESNO, TokenType.KEYWDDATATYPEAUTOCOUNTER, TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION, TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION, TokenType.KEYWDDATATYPESIGNEDBIGINTEGER, TokenType.KEYWDDATATYPESIGNEDINTEGER, TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER, TokenType.KEYWDDATATYPEOBJECTID, TokenType.KEYWDDATATYPEROWID, TokenType.KEYWDDATATYPERAWDATAOLEOBJECT, TokenType.KEYWDDATATYPERAWDATA, TokenType.KEYWDDATATYPEAUTOTIMESTAMP, TokenType.KEYWDDATATYPEDATE, TokenType.KEYWDDATATYPEDATETIME, TokenType.KEYWDDATATYPETIME) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDDATATYPELOGICALTRUEFALSE
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPELOGICALTRUEFALSE) ' Terminal Rule: KEYWDDATATYPELOGICALTRUEFALSE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPELOGICALTRUEFALSE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPELOGICALYESNO
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPELOGICALYESNO) ' Terminal Rule: KEYWDDATATYPELOGICALYESNO
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPELOGICALYESNO Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALYESNO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEAUTOCOUNTER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEAUTOCOUNTER) ' Terminal Rule: KEYWDDATATYPEAUTOCOUNTER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEAUTOCOUNTER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEAUTOCOUNTER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATDOUBLEPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATSINGLEPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDBIGINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDBIGINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDBIGINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDBIGINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDBIGINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER) ' Terminal Rule: KEYWDDATATYPESIGNEDSMALLINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER) ' Terminal Rule: KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEOBJECTID
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEOBJECTID) ' Terminal Rule: KEYWDDATATYPEOBJECTID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEOBJECTID Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEOBJECTID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEROWID
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEROWID) ' Terminal Rule: KEYWDDATATYPEROWID
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEROWID Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEROWID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAOLEOBJECT
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAOLEOBJECT) ' Terminal Rule: KEYWDDATATYPERAWDATAOLEOBJECT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATAOLEOBJECT Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAOLEOBJECT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATA
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATA) ' Terminal Rule: KEYWDDATATYPERAWDATA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATA Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEAUTOTIMESTAMP
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEAUTOTIMESTAMP) ' Terminal Rule: KEYWDDATATYPEAUTOTIMESTAMP
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEAUTOTIMESTAMP Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEAUTOTIMESTAMP.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDATE
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDATE) ' Terminal Rule: KEYWDDATATYPEDATE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDATE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDATETIME
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDATETIME) ' Terminal Rule: KEYWDDATATYPEDATETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDATETIME Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDATETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPETIME
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPETIME) ' Terminal Rule: KEYWDDATATYPETIME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPETIME Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DATATYPE

        Private Sub ParseDATATYPELENGTH(ByVal parent As ParseNode) ' NonTerminalSymbol: DATATYPELENGTH
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATATYPELENGTH), "DATATYPELENGTH")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH, TokenType.KEYWDDATATYPERAWDATALARGELENGTH, TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH, TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH, TokenType.KEYWDDATATYPESTRINGLARGELENGTH, TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATAFIXEDLENGTH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATALARGELENGTH
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATALARGELENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATALARGELENGTH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATALARGELENGTH Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATALARGELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH) ' Terminal Rule: KEYWDDATATYPERAWDATAVARIABLELENGTH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGFIXEDLENGTH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGLARGELENGTH
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGLARGELENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGLARGELENGTH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESTRINGLARGELENGTH Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGLARGELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH) ' Terminal Rule: KEYWDDATATYPESTRINGVARIABLELENGTH
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.NUMBER Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DATATYPELENGTH

        Private Sub ParseDATATYPEPRECISION(ByVal parent As ParseNode) ' NonTerminalSymbol: DATATYPEPRECISION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DATATYPEPRECISION), "DATATYPEPRECISION")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION, TokenType.KEYWDDATATYPEDECIMAL, TokenType.KEYWDDATATYPEMONEY) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION) ' Terminal Rule: KEYWDDATATYPEFLOATCUSTOMPRECISION
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDECIMAL
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEDECIMAL) ' Terminal Rule: KEYWDDATATYPEDECIMAL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEDECIMAL Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEDECIMAL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEMONEY
                    tok = m_scanner.Scan(TokenType.KEYWDDATATYPEMONEY) ' Terminal Rule: KEYWDDATATYPEMONEY
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDDATATYPEMONEY Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEMONEY.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.NUMBER Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DATATYPEPRECISION

        Private Sub ParseFACTPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTPREDICATE), "FACTPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTPREDICATE

        Private Sub ParseFACTREADING(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTREADING
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTREADING), "FACTREADING")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.MODELELEMENTNAME) ' Option Rule
                If tok.Type = TokenType.MODELELEMENTNAME Then
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Else
                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTREADING

        Private Sub ParseFACTTYPENAMESTR(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPENAMESTR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPENAMESTR), "FACTTYPENAMESTR")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.FACTTYPENAME) ' Terminal Rule: FACTTYPENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.FACTTYPENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FACTTYPENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FACTTYPENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPENAMESTR

        Private Sub ParseFACTTYPEPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEPREDICATE), "FACTTYPEPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPEPREDICATE

        Private Sub ParseFACTTYPESIMPLEPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPESIMPLEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPESIMPLEPREDICATE), "FACTTYPESIMPLEPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPESIMPLEPREDICATE

        Private Sub ParseINSERTCOLUMNLIST(ByVal parent As ParseNode) ' NonTerminalSymbol: INSERTCOLUMNLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INSERTCOLUMNLIST), "INSERTCOLUMNLIST")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA
                ParseADDITIONALCOLUMNNAME(node) ' NonTerminal Rule: ADDITIONALCOLUMNNAME
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: INSERTCOLUMNLIST

        Private Sub ParseMATCHPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: MATCHPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHPREDICATE), "MATCHPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MATCHPREDICATE

        Private Sub ParseMATCHFACTTYPEPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: MATCHFACTTYPEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHFACTTYPEPREDICATE), "MATCHFACTTYPEPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MATCHFACTTYPEPREDICATE

        Private Sub ParseMODELELEMENT(ByVal parent As ParseNode) ' NonTerminalSymbol: MODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENT), "MODELELEMENT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.PREBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.PREBOUNDREADINGTEXT) ' Terminal Rule: PREBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.POSTBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.POSTBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.POSTBOUNDREADINGTEXT) ' Terminal Rule: POSTBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.POSTBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.MODELELEMENTSUFFIX) ' Option Rule
            If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MODELELEMENT

        Private Sub ParseMODELELEMENTPLURAL(ByVal parent As ParseNode) ' NonTerminalSymbol: MODELELEMENTPLURAL
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENTPLURAL), "MODELELEMENTPLURAL")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.KEYWDENTITYTYPES, TokenType.KEYWDVALUETYPES, TokenType.KEYWDFACTTYPES, TokenType.KEYWDROLECONSTRAINTS, TokenType.KEYWDMODELNOTES) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPES
                    tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPES) ' Terminal Rule: KEYWDENTITYTYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENTITYTYPES Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPES"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDVALUETYPES
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPES) ' Terminal Rule: KEYWDVALUETYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPES Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPES"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDFACTTYPES
                    tok = m_scanner.Scan(TokenType.KEYWDFACTTYPES) ' Terminal Rule: KEYWDFACTTYPES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDFACTTYPES Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPES"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDROLECONSTRAINTS
                    tok = m_scanner.Scan(TokenType.KEYWDROLECONSTRAINTS) ' Terminal Rule: KEYWDROLECONSTRAINTS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDROLECONSTRAINTS Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDROLECONSTRAINTS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLECONSTRAINTS"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDMODELNOTES
                    tok = m_scanner.Scan(TokenType.KEYWDMODELNOTES) ' Terminal Rule: KEYWDMODELNOTES
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODELNOTES Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODELNOTES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODELNOTES"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPES"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPES"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPES"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLECONSTRAINTS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODELNOTES"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MODELELEMENTPLURAL

        Private Sub ParseMODELELEMENTSTR(ByVal parent As ParseNode) ' NonTerminalSymbol: MODELELEMENTSTR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELELEMENTSTR), "MODELELEMENTSTR")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MODELELEMENTSTR

        Private Sub ParseMODELMODELELEMENT(ByVal parent As ParseNode) ' NonTerminalSymbol: MODELMODELELEMENT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MODELMODELELEMENT), "MODELMODELELEMENT")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.KEYWDENTITYTYPE, TokenType.KEYWDVALUETYPE, TokenType.KEYWDMODEL) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPE
                    tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPE) ' Terminal Rule: KEYWDENTITYTYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDENTITYTYPE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDVALUETYPE
                    tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDVALUETYPE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDMODEL
                    tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDMODEL Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MODELMODELELEMENT

        Private Sub ParseNODESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: NODESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODESTMT), "NODESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COLON) ' Terminal Rule: COLON
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COLON Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.IDENTIFIER Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: NODESTMT

        Private Sub ParseNODE(ByVal parent As ParseNode) ' NonTerminalSymbol: NODE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODE), "NODE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.PREBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.PREBOUNDREADINGTEXT) ' Terminal Rule: PREBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.MODELELEMENTNAME

                     ' Concat Rule
                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    tok = m_scanner.LookAhead(TokenType.MODELELEMENTSUFFIX) ' Option Rule
                    If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                        tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.BROPEN
                    ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.POSTBOUNDREADINGTEXT) ' Option Rule
            If tok.Type = TokenType.POSTBOUNDREADINGTEXT Then
                tok = m_scanner.Scan(TokenType.POSTBOUNDREADINGTEXT) ' Terminal Rule: POSTBOUNDREADINGTEXT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.POSTBOUNDREADINGTEXT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POSTBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "POSTBOUNDREADINGTEXT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: NODE

        Private Sub ParseNODEPROPERTYIDENTIFICATION(ByVal parent As ParseNode) ' NonTerminalSymbol: NODEPROPERTYIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODEPROPERTYIDENTIFICATION), "NODEPROPERTYIDENTIFICATION")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.MODELELEMENTSUFFIX) ' Option Rule
            If tok.Type = TokenType.MODELELEMENTSUFFIX Then
                tok = m_scanner.Scan(TokenType.MODELELEMENTSUFFIX) ' Terminal Rule: MODELELEMENTSUFFIX
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.MODELELEMENTSUFFIX Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTSUFFIX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTSUFFIX"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COLON, TokenType.CARRET) ' ZeroOrMore Rule
            While tok.Type = TokenType.COLON Or tok.Type = TokenType.CARRET
                ParseQUOTEDIDENTIFIERLIST(node) ' NonTerminal Rule: QUOTEDIDENTIFIERLIST
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COLON, TokenType.CARRET) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: NODEPROPERTYIDENTIFICATION

        Private Sub ParseNODEIDENTIFICATION(ByVal parent As ParseNode) ' NonTerminalSymbol: NODEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.NODEIDENTIFICATION), "NODEIDENTIFICATION")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.BROPEN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.BROPEN
                    ParseMATCHPREDICATE(node) ' NonTerminal Rule: MATCHPREDICATE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.BROPEN
                    ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: NODEIDENTIFICATION

        Private Sub ParsePREDICATECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: PREDICATECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PREDICATECLAUSE), "PREDICATECLAUSE")
            parent.Nodes.Add(node)

            Do ' OneOrMore Rule
                tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREDICATE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATE) ' OneOrMore Rule
            Loop While tok.Type = TokenType.PREDICATE ' OneOrMore Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: PREDICATECLAUSE

        Private Sub ParseQUOTEDIDENTIFIER(ByVal parent As ParseNode) ' NonTerminalSymbol: QUOTEDIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.QUOTEDIDENTIFIER), "QUOTEDIDENTIFIER")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.EMAILADDRESS, TokenType.IDENTIFIER) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.EMAILADDRESS
                    tok = m_scanner.Scan(TokenType.EMAILADDRESS) ' Terminal Rule: EMAILADDRESS
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EMAILADDRESS Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EMAILADDRESS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EMAILADDRESS"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.IDENTIFIER
                    tok = m_scanner.Scan(TokenType.IDENTIFIER) ' Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.IDENTIFIER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EMAILADDRESS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EMAILADDRESS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EMAILADDRESS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "IDENTIFIER"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: QUOTEDIDENTIFIER

        Private Sub ParseQUOTEDIDENTIFIERLIST(ByVal parent As ParseNode) ' NonTerminalSymbol: QUOTEDIDENTIFIERLIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.QUOTEDIDENTIFIERLIST), "QUOTEDIDENTIFIERLIST")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COLON, TokenType.CARRET) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.COLON
                    tok = m_scanner.Scan(TokenType.COLON) ' Terminal Rule: COLON
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COLON Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.CARRET
                    tok = m_scanner.Scan(TokenType.CARRET) ' Terminal Rule: CARRET
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.CARRET Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CARRET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COLON"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CARRET"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA
                ParseADDITIONALQUOTEDIDENTIFIER(node) ' NonTerminal Rule: ADDITIONALQUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: QUOTEDIDENTIFIERLIST

        Private Sub ParseREFERENCEMODECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: REFERENCEMODECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.REFERENCEMODECLAUSE), "REFERENCEMODECLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISIDENTIFIEDBYITS) ' Terminal Rule: KEYWDISIDENTIFIEDBYITS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISIDENTIFIEDBYITS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISIDENTIFIEDBYITS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.REFERENCEMODE) ' Terminal Rule: REFERENCEMODE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.REFERENCEMODE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REFERENCEMODE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "REFERENCEMODE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDRESTRICTEDTO) ' Option Rule
            If tok.Type = TokenType.KEYWDRESTRICTEDTO Then

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDRESTRICTEDTO) ' Terminal Rule: KEYWDRESTRICTEDTO
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDRESTRICTEDTO Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRESTRICTEDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRESTRICTEDTO"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.CURLYBRACKETOPEN) ' Terminal Rule: CURLYBRACKETOPEN
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.CURLYBRACKETOPEN Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYBRACKETOPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CURLYBRACKETOPEN"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                While tok.Type = TokenType.COMMA

                     ' Concat Rule
                    tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.COMMA Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.CURLYBRACKETCLOSE) ' Terminal Rule: CURLYBRACKETCLOSE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.CURLYBRACKETCLOSE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYBRACKETCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "CURLYBRACKETCLOSE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRESTRICTEDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRESTRICTEDTO"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: REFERENCEMODECLAUSE

        Private Sub ParseRETURNCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: RETURNCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNCLAUSE), "RETURNCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDRETURN) ' Terminal Rule: KEYWDRETURN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDRETURN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDRETURN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRETURN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseRETURNPREDICATE(node) ' NonTerminal Rule: RETURNPREDICATE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: RETURNCLAUSE

        Private Sub ParseRETURNFACTTYPEPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: RETURNFACTTYPEPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNFACTTYPEPREDICATE), "RETURNFACTTYPEPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: RETURNFACTTYPEPREDICATE

        Private Sub ParseRETURNPREDICATE(ByVal parent As ParseNode) ' NonTerminalSymbol: RETURNPREDICATE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.RETURNPREDICATE), "RETURNPREDICATE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                While tok.Type = TokenType.PREDICATESPACE
                    tok = m_scanner.Scan(TokenType.PREDICATESPACE) ' Terminal Rule: PREDICATESPACE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.PREDICATESPACE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATESPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATESPACE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.PREDICATESPACE) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: RETURNPREDICATE

        Private Sub ParseROLENAMESTR(ByVal parent As ParseNode) ' NonTerminalSymbol: ROLENAMESTR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ROLENAMESTR), "ROLENAMESTR")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.ROLENAME) ' Terminal Rule: ROLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.ROLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "ROLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ROLENAMESTR

        Private Sub ParseSETCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: SETCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SETCLAUSE), "SETCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDSET) ' Terminal Rule: KEYWDSET
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDSET Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSET"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: SETCLAUSE

        Private Sub ParseVALUELIST(ByVal parent As ParseNode) ' NonTerminalSymbol: VALUELIST
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.VALUELIST), "VALUELIST")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BROPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA
                ParseADDITIONALVALUE(node) ' NonTerminal Rule: ADDITIONALVALUE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.BRCLOSE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: VALUELIST

        Private Sub ParseVALUESTRING(ByVal parent As ParseNode) ' NonTerminalSymbol: VALUESTRING
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.VALUESTRING), "VALUESTRING")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.VALUE) ' Terminal Rule: VALUE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.VALUE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VALUE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "VALUE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: VALUESTRING

        Private Sub ParseADDENTITYTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDENTITYTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDENTITYTYPESTMT), "ADDENTITYTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPE) ' Terminal Rule: KEYWDENTITYTYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDENTITYTYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTO Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDPAGE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.PAGENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDENTITYTYPESTMT

        Private Sub ParseADDFACTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDFACTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDFACTSTMT), "ADDFACTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDADDFACT) ' Terminal Rule: KEYWDADDFACT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDADDFACT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADDFACT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTO Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDONPAGE) ' Option Rule
            If tok.Type = TokenType.KEYWDONPAGE Then

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDONPAGE) ' Terminal Rule: KEYWDONPAGE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDONPAGE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDONPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONPAGE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.SINGLEQUOTE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PAGENAME Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.SINGLEQUOTE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDONPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONPAGE"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDFACTSTMT

        Private Sub ParseADDFACTTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDFACTTYPESTMT), "ADDFACTTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFACTTYPE) ' Terminal Rule: KEYWDFACTTYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFACTTYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTO Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDPAGE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.PAGENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDFACTTYPESTMT

        Private Sub ParseADDROLESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDROLESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDROLESTMT), "ADDROLESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDROLE) ' Terminal Rule: KEYWDROLE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDROLE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDROLE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseROLENAMESTR(node) ' NonTerminal Rule: ROLENAMESTR
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTO Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFACTTYPE) ' Terminal Rule: KEYWDFACTTYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFACTTYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDJOINING) ' Terminal Rule: KEYWDJOINING
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDJOINING Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDJOINING.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDJOINING"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDROLESTMT

        Private Sub ParseADDMODELELEMENTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDMODELELEMENTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDMODELELEMENTSTMT), "ADDMODELELEMENTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDADD) ' Terminal Rule: KEYWDADD
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDADD Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADD.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADD"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDENTITYTYPE, TokenType.KEYWDADDFACT, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE, TokenType.KEYWDROLE) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPE
                    ParseADDENTITYTYPESTMT(node) ' NonTerminal Rule: ADDENTITYTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDADDFACT
                    ParseADDFACTSTMT(node) ' NonTerminal Rule: ADDFACTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDFACTTYPE
                    ParseADDFACTTYPESTMT(node) ' NonTerminal Rule: ADDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDVALUETYPE
                    ParseADDVALUETYPESTMT(node) ' NonTerminal Rule: ADDVALUETYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDROLE
                    ParseADDROLESTMT(node) ' NonTerminal Rule: ADDROLESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADDFACT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDROLE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDMODELELEMENTSTMT

        Private Sub ParseADDVALUETYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ADDVALUETYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ADDVALUETYPESTMT), "ADDVALUETYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDVALUETYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTO) ' Terminal Rule: KEYWDTO
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTO Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTO"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDPAGE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.PAGENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ADDVALUETYPESTMT

        Private Sub ParseASSERTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ASSERTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ASSERTSTMT), "ASSERTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDASSERT) ' Terminal Rule: KEYWDASSERT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDASSERT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDASSERT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDASSERT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDISWRITTENAS, TokenType.BROPEN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDISWRITTENAS
                    ParseVALUETYPEISWRITTENASSTMT(node) ' NonTerminal Rule: VALUETYPEISWRITTENASSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.BROPEN
                    ParseFACTSTMT(node) ' NonTerminal Rule: FACTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWRITTENAS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ASSERTSTMT

        Private Sub ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BINARYFACTTYPEMANYTOONEDEFINITIONSTMT), "BINARYFACTTYPEMANYTOONEDEFINITIONSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDONE) ' Terminal Rule: KEYWDONE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDONE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.ROLENAME) ' Option Rule
            If tok.Type = TokenType.ROLENAME Then
                tok = m_scanner.Scan(TokenType.ROLENAME) ' Terminal Rule: ROLENAME
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.ROLENAME Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "ROLENAME"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "ROLENAME"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT

        Private Sub ParseCONSTRAINTEITHEROREXTERNAL(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTEITHEROREXTERNAL
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEITHEROREXTERNAL), "CONSTRAINTEITHEROREXTERNAL")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOR) ' Terminal Rule: KEYWDOR
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOR Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOR"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDBUTNOTBOTH) ' Option Rule
            If tok.Type = TokenType.KEYWDBUTNOTBOTH Then
                tok = m_scanner.Scan(TokenType.KEYWDBUTNOTBOTH) ' Terminal Rule: KEYWDBUTNOTBOTH
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDBUTNOTBOTH Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTEITHEROREXTERNAL

        Private Sub ParseCONSTRAINTEITHERORSUBTYPE(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTEITHERORSUBTYPE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEITHERORSUBTYPE), "CONSTRAINTEITHERORSUBTYPE")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseSUBTYPESTMT(node) ' NonTerminal Rule: SUBTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOR) ' Terminal Rule: KEYWDOR
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOR Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOR"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseSUBTYPESTMT(node) ' NonTerminal Rule: SUBTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDBUTNOTBOTH) ' Option Rule
            If tok.Type = TokenType.KEYWDBUTNOTBOTH Then
                tok = m_scanner.Scan(TokenType.KEYWDBUTNOTBOTH) ' Terminal Rule: KEYWDBUTNOTBOTH
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDBUTNOTBOTH Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDBUTNOTBOTH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDBUTNOTBOTH"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTEITHERORSUBTYPE

        Private Sub ParseCONSTRAINTEITHEROR(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTEITHEROR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEITHEROR), "CONSTRAINTEITHEROR")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDEITHER) ' Terminal Rule: KEYWDEITHER
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDEITHER Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDEITHER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEITHER"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.MODELELEMENTNAME) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.MODELELEMENTNAME
                    ParseCONSTRAINTEITHEROREXTERNAL(node) ' NonTerminal Rule: CONSTRAINTEITHEROREXTERNAL
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseCONSTRAINTEITHERORSUBTYPE(node) ' NonTerminal Rule: CONSTRAINTEITHERORSUBTYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTEITHEROR

        Private Sub ParseCONSTRAINTEXTERNALUNIQUENESS(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTEXTERNALUNIQUENESS
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEXTERNALUNIQUENESS), "CONSTRAINTEXTERNALUNIQUENESS")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDCOMBINATION) ' Terminal Rule: KEYWDCOMBINATION
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDCOMBINATION Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOMBINATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOMBINATION"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOF) ' Terminal Rule: KEYWDOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.COMMA Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.MODELELEMENTNAME Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOCCURSATLEASTONETIMEINEACHOF) ' Terminal Rule: KEYWDOCCURSATLEASTONETIMEINEACHOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOCCURSATLEASTONETIMEINEACHOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOCCURSATLEASTONETIMEINEACHOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOCCURSATLEASTONETIMEINEACHOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.COMMA Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTEXTERNALUNIQUENESS

        Private Sub ParseCONSTRAINTINCLUSIVEOR(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTINCLUSIVEOR
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTINCLUSIVEOR), "CONSTRAINTINCLUSIVEOR")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDNULL) ' Terminal Rule: KEYWDNULL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDNULL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNULL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNULL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOCCURSATLEASTONETIME) ' Terminal Rule: KEYWDOCCURSATLEASTONETIME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOCCURSATLEASTONETIME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOCCURSATLEASTONETIME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOCCURSATLEASTONETIME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            While tok.Type = TokenType.COMMA

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.COMMA Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTINCLUSIVEOR

        Private Sub ParseCONSTRAINTEXTERNALSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTEXTERNALSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTEXTERNALSTMT), "CONSTRAINTEXTERNALSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDEACH) ' Terminal Rule: KEYWDEACH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDEACH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDEACH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEACH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDCOMBINATION, TokenType.KEYWDNULL) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDCOMBINATION
                    ParseCONSTRAINTEXTERNALUNIQUENESS(node) ' NonTerminal Rule: CONSTRAINTEXTERNALUNIQUENESS
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDNULL
                    ParseCONSTRAINTINCLUSIVEOR(node) ' NonTerminal Rule: CONSTRAINTINCLUSIVEOR
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOMBINATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOMBINATION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOMBINATION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNULL"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTEXTERNALSTMT

        Private Sub ParseCONSTRAINTMANDATORY(ByVal parent As ParseNode) ' NonTerminalSymbol: CONSTRAINTMANDATORY
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CONSTRAINTMANDATORY), "CONSTRAINTMANDATORY")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISA) ' Terminal Rule: KEYWDISA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTHAT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDIFANDONLYIF) ' Terminal Rule: KEYWDIFANDONLYIF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDIFANDONLYIF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIFANDONLYIF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIFANDONLYIF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseSUBTYPESTMT(node) ' NonTerminal Rule: SUBTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CONSTRAINTMANDATORY

        Private Sub ParseCREATECONCEPTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATECONCEPTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATECONCEPTSTMT), "CREATECONCEPTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDCREATECONCEPT) ' Terminal Rule: KEYWDCREATECONCEPT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDCREATECONCEPT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCREATECONCEPT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATECONCEPT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATECONCEPTSTMT

        Private Sub ParseCREATEENTITYTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATEENTITYTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEENTITYTYPESTMT), "CREATEENTITYTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDENTITYTYPE) ' Terminal Rule: KEYWDENTITYTYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDENTITYTYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATEENTITYTYPESTMT

        Private Sub ParseCREATEFACTTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATEFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEFACTTYPESTMT), "CREATEFACTTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFACTTYPE) ' Terminal Rule: KEYWDFACTTYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFACTTYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFACTTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.SINGLEQUOTE) ' Option Rule
            If tok.Type = TokenType.SINGLEQUOTE Then
                ParseFACTTYPENAMESTR(node) ' NonTerminal Rule: FACTTYPENAMESTR
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFOR) ' Terminal Rule: KEYWDFOR
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFOR Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFOR.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFOR"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATEFACTTYPESTMT

        Private Sub ParseCREATEMODELSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATEMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEMODELSTMT), "CREATEMODELSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDCREATEMODEL) ' Terminal Rule: KEYWDCREATEMODEL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDCREATEMODEL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCREATEMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATEMODEL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATEMODELSTMT

        Private Sub ParseCREATEMODELELEMENTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATEMODELELEMENTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEMODELELEMENTSTMT), "CREATEMODELELEMENTSTMT")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDENTITYTYPE
                    ParseCREATEENTITYTYPESTMT(node) ' NonTerminal Rule: CREATEENTITYTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDFACTTYPE
                    ParseCREATEFACTTYPESTMT(node) ' NonTerminal Rule: CREATEFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDVALUETYPE
                    ParseCREATEVALUETYPESTMT(node) ' NonTerminal Rule: CREATEVALUETYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENTITYTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATEMODELELEMENTSTMT

        Private Sub ParseCREATESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATESTMT), "CREATESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDCREATE) ' Terminal Rule: KEYWDCREATE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDCREATE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCREATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.BROPEN, TokenType.KEYWDENTITYTYPE, TokenType.KEYWDFACTTYPE, TokenType.KEYWDVALUETYPE) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.BROPEN
                    ParseFACTPREDICATE(node) ' NonTerminal Rule: FACTPREDICATE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDENTITYTYPE
                    ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDFACTTYPE
                    ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDVALUETYPE
                    ParseCREATEMODELELEMENTSTMT(node) ' NonTerminal Rule: CREATEMODELELEMENTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENTITYTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFACTTYPE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDTHAT) ' Option Rule
            If tok.Type = TokenType.KEYWDTHAT Then

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDTHAT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                While tok.Type = TokenType.KEYWDAND

                     ' Concat Rule
                    tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDAND Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    ParsePREDICATENODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: PREDICATENODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
                End While
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATESTMT

        Private Sub ParseCREATEVALUETYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: CREATEVALUETYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.CREATEVALUETYPESTMT), "CREATEVALUETYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDVALUETYPE) ' Terminal Rule: KEYWDVALUETYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDVALUETYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUETYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUETYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: CREATEVALUETYPESTMT

        Private Sub ParseDELETESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: DELETESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETESTMT), "DELETESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDDELETE) ' Terminal Rule: KEYWDDELETE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDDELETE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDELETE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.BROPEN, TokenType.KEYWDFROM) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.BROPEN
                    ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDFROM
                    ParseDELETEFROMCLAUSE(node) ' NonTerminal Rule: DELETEFROMCLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DELETESTMT

        Private Sub ParseDELETEFROMCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: DELETEFROMCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETEFROMCLAUSE), "DELETEFROMCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFROM Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDON) ' Option Rule
            If tok.Type = TokenType.KEYWDON Then
                ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWHERE) ' Terminal Rule: KEYWDWHERE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWHERE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND
                ParseADDITIONALCOMPARISON(node) ' NonTerminal Rule: ADDITIONALCOMPARISON
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DELETEFROMCLAUSE

        Private Sub ParseDELETEALLSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: DELETEALLSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETEALLSTMT), "DELETEALLSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDDELETEALL) ' Terminal Rule: KEYWDDELETEALL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDDELETEALL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDELETEALL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEALL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFROM Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DELETEALLSTMT

        Private Sub ParseDELETEFACTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: DELETEFACTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DELETEFACTSTMT), "DELETEFACTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDDELETEFACT) ' Terminal Rule: KEYWDDELETEFACT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDDELETEFACT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDELETEFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEFACT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFROM Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDON) ' Option Rule
            If tok.Type = TokenType.KEYWDON Then
                ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DELETEFACTSTMT

        Private Sub ParseDERIVATIONSUBCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: DERIVATIONSUBCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVATIONSUBCLAUSE), "DERIVATIONSUBCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.EXPRESSIONSYMBOL, TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.EXPRESSIONSYMBOL Or tok.Type = TokenType.PREDICATE
                tok = m_scanner.LookAhead(TokenType.EXPRESSIONSYMBOL, TokenType.PREDICATE) ' Choice Rule
                Select Case tok.Type
                 ' Choice Rule
                    Case TokenType.EXPRESSIONSYMBOL

                         ' Concat Rule
                        ParseEXPRESSION(node) ' NonTerminal Rule: EXPRESSION
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.PREDICATE

                         ' Concat Rule
                        ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDCOUNT Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.MODELELEMENTNAME Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case Else
                    If m_tree.Errors.Count = 0 Then
                    m_tree.Optionals.Clear
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                    End If
                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                        Exit Select
                End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.EXPRESSIONSYMBOL, TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DERIVATIONSUBCLAUSE

        Private Sub ParseDERIVATIONCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: DERIVATIONCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVATIONCLAUSE), "DERIVATIONCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISWHERE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseDERIVATIONSUBCLAUSE(node) ' NonTerminal Rule: DERIVATIONSUBCLAUSE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' Option Rule
            If tok.Type = TokenType.KEYWDAND Then

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseDERIVATIONSUBCLAUSE(node) ' NonTerminal Rule: DERIVATIONSUBCLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DERIVATIONCLAUSE

        Private Sub ParseDERIVEDFACTTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: DERIVEDFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DERIVEDFACTTYPESTMT), "DERIVEDFACTTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDA, TokenType.KEYWDAN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDA
                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDA Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDAN
                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDAN Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWHEN) ' Terminal Rule: KEYWDWHEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWHEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESIMPLEPREDICATE(node) ' NonTerminal Rule: FACTTYPESIMPLEPREDICATE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseFACTTYPESIMPLEPREDICATE(node) ' NonTerminal Rule: FACTTYPESIMPLEPREDICATE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DERIVEDFACTTYPESTMT

        Private Sub ParseDESCRIBESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: DESCRIBESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DESCRIBESTMT), "DESCRIBESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDDESCRIBE) ' Terminal Rule: KEYWDDESCRIBE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDDESCRIBE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDESCRIBE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDESCRIBE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SPACE) ' Terminal Rule: SPACE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SPACE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SPACE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DESCRIBESTMT

        Private Sub ParseDIDSELECTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: DIDSELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.DIDSELECTSTMT), "DIDSELECTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDDID) ' Terminal Rule: KEYWDDID
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDDID Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDID"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDA) ' Option Rule
            If tok.Type = TokenType.KEYWDA Then
                tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDA Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.PREBOUNDREADINGTEXT
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREBOUNDREADINGTEXT
                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.BROPEN
                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND Or tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDWITH Or tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Or tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.BROPEN Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION
                ParseWHICHCLAUSE(node) ' NonTerminal Rule: WHICHCLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: DIDSELECTSTMT

        Private Sub ParseENTITYTYPEISIDENTIFIEDBYITSCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ENTITYTYPEISIDENTIFIEDBYITSCLAUSE), "ENTITYTYPEISIDENTIFIEDBYITSCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISIDENTIFIEDBYITS) ' Terminal Rule: KEYWDISIDENTIFIEDBYITS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISIDENTIFIEDBYITS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISIDENTIFIEDBYITS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.REFERENCEMODE) ' Terminal Rule: REFERENCEMODE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.REFERENCEMODE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REFERENCEMODE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "REFERENCEMODE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDWRITTENAS) ' Option Rule
            If tok.Type = TokenType.KEYWDWRITTENAS Then
                ParseWRITTENASCLAUSE(node) ' NonTerminal Rule: WRITTENASCLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWRITTENAS"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE

        Private Sub ParseENUMERATESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ENUMERATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ENUMERATESTMT), "ENUMERATESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDENUMERATE) ' Terminal Rule: KEYWDENUMERATE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDENUMERATE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDENUMERATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENUMERATE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SPACE) ' Terminal Rule: SPACE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SPACE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SPACE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDINDEX) ' Option Rule
            If tok.Type = TokenType.KEYWDINDEX Then

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDINDEX) ' Terminal Rule: KEYWDINDEX
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDINDEX Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINDEX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINDEX"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.SPACE) ' Terminal Rule: SPACE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.SPACE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPACE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SPACE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINDEX.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINDEX"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ENUMERATESTMT

        Private Sub ParseEXPRESSION(ByVal parent As ParseNode) ' NonTerminalSymbol: EXPRESSION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXPRESSION), "EXPRESSION")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EXPRESSIONSYMBOL) ' Terminal Rule: EXPRESSIONSYMBOL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EXPRESSIONSYMBOL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPRESSIONSYMBOL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EXPRESSIONSYMBOL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: EXPRESSION

        Private Sub ParseEXISTSSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: EXISTSSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXISTSSTMT), "EXISTSSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDEXISTS) ' Terminal Rule: KEYWDEXISTS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDEXISTS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDEXISTS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEXISTS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: EXISTSSTMT

        Private Sub ParseEXTERNALUNIQUENESSCONSTRAINTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: EXTERNALUNIQUENESSCONSTRAINTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.EXTERNALUNIQUENESSCONSTRAINTSTMT), "EXTERNALUNIQUENESSCONSTRAINTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFOREACH) ' Terminal Rule: KEYWDFOREACH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFOREACH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFOREACH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFOREACH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND
                ParseADDITIONALMODELELEMENT(node) ' NonTerminal Rule: ADDITIONALMODELELEMENT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDATMOSTONE) ' Terminal Rule: KEYWDATMOSTONE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDATMOSTONE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.PREDICATE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDTHAT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDAND Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREDICATE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDTHAT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.MODELELEMENTNAME Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: EXTERNALUNIQUENESSCONSTRAINTSTMT

        Private Sub ParseFACTTYPEISWHERESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPEISWHERESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEISWHERESTMT), "FACTTYPEISWHERESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISWHERE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.COMMA Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPEISWHERESTMT

        Private Sub ParseFACTTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPESTMT), "FACTTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseFACTTYPEIDENTIFICATION(node) ' NonTerminal Rule: FACTTYPEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.MODELELEMENTNAME Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPESTMT

        Private Sub ParseFACTTYPEIDENTIFICATION(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEIDENTIFICATION), "FACTTYPEIDENTIFICATION")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE, TokenType.KEYWDISA) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.PREDICATE
                    ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDISA
                    tok = m_scanner.Scan(TokenType.KEYWDISA) ' Terminal Rule: KEYWDISA
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISA Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISA"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPEIDENTIFICATION

        Private Sub ParseFACTTYPEPARTCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPEPARTCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEPARTCLAUSE), "FACTTYPEPARTCLAUSE")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.MODELELEMENTNAME Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPEPARTCLAUSE

        Private Sub ParseBINARYFACTTYPECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: BINARYFACTTYPECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.BINARYFACTTYPECLAUSE), "BINARYFACTTYPECLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDATMOSTONE) ' Terminal Rule: KEYWDATMOSTONE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDATMOSTONE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: BINARYFACTTYPECLAUSE

        Private Sub ParseFACTTYPEPRODUCTION(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTTYPEPRODUCTION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTTYPEPRODUCTION), "FACTTYPEPRODUCTION")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDNULL) ' Terminal Rule: KEYWDNULL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDNULL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDNULL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNULL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDISWRITTENAS, TokenType.KEYWDISIDENTIFIEDBYITS, TokenType.KEYWDISWHERE, TokenType.PREDICATE, TokenType.KEYWDISAKINDOF) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDISWRITTENAS
                    ParseVALUETYPEISWRITTENASSTMT(node) ' NonTerminal Rule: VALUETYPEISWRITTENASSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDISIDENTIFIEDBYITS
                    ParseENTITYTYPEISIDENTIFIEDBYITSCLAUSE(node) ' NonTerminal Rule: ENTITYTYPEISIDENTIFIEDBYITSCLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDISIDENTIFIEDBYITS
                    ParseREFERENCEMODECLAUSE(node) ' NonTerminal Rule: REFERENCEMODECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDISWHERE

                     ' Concat Rule
                    tok = m_scanner.Scan(TokenType.KEYWDISWHERE) ' Terminal Rule: KEYWDISWHERE
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDISWHERE Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    While tok.Type = TokenType.COMMA

                         ' Concat Rule
                        tok = m_scanner.Scan(TokenType.COMMA) ' Terminal Rule: COMMA
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.COMMA Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "COMMA"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        ParseFACTTYPESTMT(node) ' NonTerminal Rule: FACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    tok = m_scanner.LookAhead(TokenType.COMMA) ' ZeroOrMore Rule
                    End While
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREDICATE

                     ' Concat Rule
                    ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    tok = m_scanner.LookAhead(TokenType.KEYWDATMOSTONE, TokenType.KEYWDONE, TokenType.MODELELEMENTNAME) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDATMOSTONE
                            ParseBINARYFACTTYPECLAUSE(node) ' NonTerminal Rule: BINARYFACTTYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.KEYWDONE
                            ParseBINARYFACTTYPEMANYTOONEDEFINITIONSTMT(node) ' NonTerminal Rule: BINARYFACTTYPEMANYTOONEDEFINITIONSTMT
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.MODELELEMENTNAME

                             ' Concat Rule
                            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.MODELELEMENTNAME Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If

                             ' Concat Rule
                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                            While tok.Type = TokenType.PREDICATE

                                 ' Concat Rule
                                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                            parent.Token.UpdateRange(node.Token)
                                            Exit Sub
            End If

                                 ' Concat Rule
                                tok = m_scanner.LookAhead(TokenType.MODELELEMENTNAME) ' Option Rule
                                If tok.Type = TokenType.MODELELEMENTNAME Then
                                    tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.MODELELEMENTNAME Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Else
                                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                End If
            If m_tree.Errors.Count > 0 Then
                                            parent.Token.UpdateRange(node.Token)
                                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                            parent.Token.UpdateRange(node.Token)
                                            Exit Sub
            End If
                            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
                            End While
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDATMOSTONE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDONE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDATMOSTONE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    tok = m_scanner.LookAhead(TokenType.KEYWDISWHERE) ' Option Rule
                    If tok.Type = TokenType.KEYWDISWHERE Then
                        ParseDERIVATIONCLAUSE(node) ' NonTerminal Rule: DERIVATIONCLAUSE
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Else
                                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                    End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDISAKINDOF
                    ParseSUBTYPECLAUSE(node) ' NonTerminal Rule: SUBTYPECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWRITTENAS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISIDENTIFIEDBYITS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWHERE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISAKINDOF"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTTYPEPRODUCTION

        Private Sub ParseFACTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: FACTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.FACTSTMT), "FACTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: FACTSTMT

        Private Sub ParseGETSUPERTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: GETSUPERTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.GETSUPERTYPESTMT), "GETSUPERTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDGET) ' Terminal Rule: KEYWDGET
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDGET Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDGET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDGET"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDSUPERTYPE) ' Terminal Rule: KEYWDSUPERTYPE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDSUPERTYPE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSUPERTYPE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSUPERTYPE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOF) ' Terminal Rule: KEYWDOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: GETSUPERTYPESTMT

        Private Sub ParseINDIVIDUALIDENTIFIER(ByVal parent As ParseNode) ' NonTerminalSymbol: INDIVIDUALIDENTIFIER
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INDIVIDUALIDENTIFIER), "INDIVIDUALIDENTIFIER")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.NUMBER
                    tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.NUMBER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.SINGLEQUOTE
                    ParseQUOTEDIDENTIFIER(node) ' NonTerminal Rule: QUOTEDIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: INDIVIDUALIDENTIFIER

        Private Sub ParseINMODELSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: INMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INMODELSTMT), "INMODELSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDIN) ' Terminal Rule: KEYWDIN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDIN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDMODEL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELID) ' Terminal Rule: MODELID
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELID Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELID.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELID"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: INMODELSTMT

        Private Sub ParseINSERTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: INSERTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.INSERTSTMT), "INSERTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDINSERT) ' Terminal Rule: KEYWDINSERT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDINSERT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINSERT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINSERT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDINTO) ' Terminal Rule: KEYWDINTO
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDINTO Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDINTO.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDINTO"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.BROPEN) ' Option Rule
            If tok.Type = TokenType.BROPEN Then
                ParseINSERTCOLUMNLIST(node) ' NonTerminal Rule: INSERTCOLUMNLIST
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDON) ' Option Rule
            If tok.Type = TokenType.KEYWDON Then
                ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDIN) ' Option Rule
            If tok.Type = TokenType.KEYWDIN Then
                ParseINMODELSTMT(node) ' NonTerminal Rule: INMODELSTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIN"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDVALUES) ' Terminal Rule: KEYWDVALUES
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDVALUES Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDVALUES.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDVALUES"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUELIST(node) ' NonTerminal Rule: VALUELIST
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: INSERTSTMT

        Private Sub ParseITISMANDATORYTHATSTMNT(ByVal parent As ParseNode) ' NonTerminalSymbol: ITISMANDATORYTHATSTMNT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ITISMANDATORYTHATSTMNT), "ITISMANDATORYTHATSTMNT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDITISMANDATORYTHAT) ' Terminal Rule: KEYWDITISMANDATORYTHAT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDITISMANDATORYTHAT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDITISMANDATORYTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDITISMANDATORYTHAT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseFACTREADING(node) ' NonTerminal Rule: FACTREADING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ITISMANDATORYTHATSTMNT

        Private Sub ParseLISTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: LISTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.LISTSTMT), "LISTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDLIST) ' Terminal Rule: KEYWDLIST
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDLIST Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDLIST.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDLIST"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMODELELEMENTPLURAL(node) ' NonTerminal Rule: MODELELEMENTPLURAL
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: LISTSTMT

        Private Sub ParseMATCHFACTTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: MATCHFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHFACTTYPESTMT), "MATCHFACTTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDMATCH) ' Terminal Rule: KEYWDMATCH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDMATCH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMATCH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseSETCLAUSE(node) ' NonTerminal Rule: SETCLAUSE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MATCHFACTTYPESTMT

        Private Sub ParseMATCHSELECTSETFACTTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: MATCHSELECTSETFACTTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHSELECTSETFACTTYPESTMT), "MATCHSELECTSETFACTTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDMATCH) ' Terminal Rule: KEYWDMATCH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDMATCH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMATCH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseSETCLAUSE(node) ' NonTerminal Rule: SETCLAUSE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MATCHSELECTSETFACTTYPESTMT

        Private Sub ParseMATHCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: MATHCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATHCLAUSE), "MATHCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MATHFUNCTION) ' Terminal Rule: MATHFUNCTION
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MATHFUNCTION Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MATHFUNCTION.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.NUMBER
                    tok = m_scanner.Scan(TokenType.NUMBER) ' Terminal Rule: NUMBER
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.NUMBER Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREBOUNDREADINGTEXT
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MATHCLAUSE

        Private Sub ParseMATCHSELECTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: MATCHSELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.MATCHSELECTSTMT), "MATCHSELECTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDMATCH) ' Terminal Rule: KEYWDMATCH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDMATCH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMATCH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseMATCHFACTTYPEPREDICATE(node) ' NonTerminal Rule: MATCHFACTTYPEPREDICATE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDSET, TokenType.KEYWDRETURN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDSET
                    ParseSETCLAUSE(node) ' NonTerminal Rule: SETCLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDRETURN
                    ParseRETURNCLAUSE(node) ' NonTerminal Rule: RETURNCLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSET"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDRETURN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: MATCHSELECTSTMT

        Private Sub ParseONPAGESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: ONPAGESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.ONPAGESTMT), "ONPAGESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDON) ' Terminal Rule: KEYWDON
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDON Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDPAGE) ' Terminal Rule: KEYWDPAGE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDPAGE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPAGE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPAGE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.PAGENAME) ' Terminal Rule: PAGENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.PAGENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAGENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PAGENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.SINGLEQUOTE) ' Terminal Rule: SINGLEQUOTE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.SINGLEQUOTE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLEQUOTE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: ONPAGESTMT

        Private Sub ParseOPENMODELSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: OPENMODELSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.OPENMODELSTMT), "OPENMODELSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDOPEN) ' Terminal Rule: KEYWDOPEN
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDOPEN Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDOPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDOPEN"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDMODEL) ' Terminal Rule: KEYWDMODEL
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDMODEL Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDMODEL.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMODEL"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELNAME) ' Terminal Rule: MODELNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: OPENMODELSTMT

        Private Sub ParsePREDICATENODEPROPERTYIDENTIFICATION(ByVal parent As ParseNode) ' NonTerminalSymbol: PREDICATENODEPROPERTYIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.PREDICATENODEPROPERTYIDENTIFICATION), "PREDICATENODEPROPERTYIDENTIFICATION")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: PREDICATENODEPROPERTYIDENTIFICATION

        Private Sub ParseSELECTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: SELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SELECTSTMT), "SELECTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDSELECT) ' Terminal Rule: KEYWDSELECT
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDSELECT Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSELECT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSELECT"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDDISTINCT) ' Option Rule
            If tok.Type = TokenType.KEYWDDISTINCT Then
                tok = m_scanner.Scan(TokenType.KEYWDDISTINCT) ' Terminal Rule: KEYWDDISTINCT
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.KEYWDDISTINCT Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDISTINCT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDISTINCT"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDISTINCT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDISTINCT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOLUMNLIST(node) ' NonTerminal Rule: COLUMNLIST
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDFROM) ' Terminal Rule: KEYWDFROM
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDFROM Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDFROM.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDFROM"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDON) ' Option Rule
            If tok.Type = TokenType.KEYWDON Then
                ParseONPAGESTMT(node) ' NonTerminal Rule: ONPAGESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDON.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDON"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDWHERE) ' Option Rule
            If tok.Type = TokenType.KEYWDWHERE Then
                ParseWHERESTMT(node) ' NonTerminal Rule: WHERESTMT
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: SELECTSTMT

        Private Sub ParseSHOWSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: SHOWSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SHOWSTMT), "SHOWSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDSHOW) ' Terminal Rule: KEYWDSHOW
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDSHOW Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSHOW.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHOW"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: SHOWSTMT

        Private Sub ParseSUBTYPECLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: SUBTYPECLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SUBTYPECLAUSE), "SUBTYPECLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISAKINDOF) ' Terminal Rule: KEYWDISAKINDOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISAKINDOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISAKINDOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISAKINDOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: SUBTYPECLAUSE

        Private Sub ParseSUBTYPESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: SUBTYPESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.SUBTYPESTMT), "SUBTYPESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            ParseFACTTYPEIDENTIFICATION(node) ' NonTerminal Rule: FACTTYPEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: SUBTYPESTMT

        Private Sub ParseTABLEIDENTIFICATION(ByVal parent As ParseNode) ' NonTerminalSymbol: TABLEIDENTIFICATION
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.TABLEIDENTIFICATION), "TABLEIDENTIFICATION")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.BROPEN) ' Option Rule
            If tok.Type = TokenType.BROPEN Then
                tok = m_scanner.Scan(TokenType.BROPEN) ' Terminal Rule: BROPEN
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.BROPEN Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.MODELELEMENTNAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.BRCLOSE) ' Option Rule
            If tok.Type = TokenType.BRCLOSE Then
                tok = m_scanner.Scan(TokenType.BRCLOSE) ' Terminal Rule: BRCLOSE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.BRCLOSE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BRCLOSE"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            While tok.Type = TokenType.PREDICATE

                 ' Concat Rule
                tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                n = node.CreateNode(tok, tok.ToString() )
                node.Token.UpdateRange(tok)
                node.Nodes.Add(n)
                If tok.Type <> TokenType.PREDICATE Then
                    m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                    Return

                End If

            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If

                 ' Concat Rule
                tok = m_scanner.LookAhead(TokenType.BROPEN, TokenType.KEYWDWHICH) ' Choice Rule
                Select Case tok.Type
                 ' Choice Rule
                    Case TokenType.BROPEN
                        ParseNODEIDENTIFICATION(node) ' NonTerminal Rule: NODEIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDWHICH

                         ' Concat Rule
                        tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDWHICH Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.Scan(TokenType.MODELELEMENTNAME) ' Terminal Rule: MODELELEMENTNAME
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.MODELELEMENTNAME Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODELELEMENTNAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case Else
                    If m_tree.Errors.Count = 0 Then
                    m_tree.Optionals.Clear
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                    End If
                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                        Exit Select
                End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.PREDICATE) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: TABLEIDENTIFICATION

        Private Sub ParseUPDATESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: UPDATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.UPDATESTMT), "UPDATESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDUPDATE) ' Terminal Rule: KEYWDUPDATE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDUPDATE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDUPDATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDUPDATE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.USERTABLENAME) ' Terminal Rule: USERTABLENAME
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.USERTABLENAME Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USERTABLENAME.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "USERTABLENAME"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDSET) ' Terminal Rule: KEYWDSET
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDSET Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDSET.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSET"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EQUALS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWHERE) ' Terminal Rule: KEYWDWHERE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWHERE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOLUMNNAME(node) ' NonTerminal Rule: COLUMNNAME
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EQUALS) ' Terminal Rule: EQUALS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EQUALS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EQUALS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUESTRING(node) ' NonTerminal Rule: VALUESTRING
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: UPDATESTMT

        Private Sub ParseVALUETYPEISWRITTENASSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: VALUETYPEISWRITTENASSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.VALUETYPEISWRITTENASSTMT), "VALUETYPEISWRITTENASSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDISWRITTENAS) ' Terminal Rule: KEYWDISWRITTENAS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDISWRITTENAS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISWRITTENAS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDDATATYPELOGICALTRUEFALSE, TokenType.KEYWDDATATYPELOGICALYESNO, TokenType.KEYWDDATATYPEAUTOCOUNTER, TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION, TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION, TokenType.KEYWDDATATYPESIGNEDBIGINTEGER, TokenType.KEYWDDATATYPESIGNEDINTEGER, TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER, TokenType.KEYWDDATATYPEOBJECTID, TokenType.KEYWDDATATYPEROWID, TokenType.KEYWDDATATYPERAWDATAOLEOBJECT, TokenType.KEYWDDATATYPERAWDATA, TokenType.KEYWDDATATYPEAUTOTIMESTAMP, TokenType.KEYWDDATATYPEDATE, TokenType.KEYWDDATATYPEDATETIME, TokenType.KEYWDDATATYPETIME, TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH, TokenType.KEYWDDATATYPERAWDATALARGELENGTH, TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH, TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH, TokenType.KEYWDDATATYPESTRINGLARGELENGTH, TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH, TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION, TokenType.KEYWDDATATYPEDECIMAL, TokenType.KEYWDDATATYPEMONEY) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDDATATYPELOGICALTRUEFALSE
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPELOGICALYESNO
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEAUTOCOUNTER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDBIGINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEOBJECTID
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEROWID
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAOLEOBJECT
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATA
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEAUTOTIMESTAMP
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDATE
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDATETIME
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPETIME
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATALARGELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGLARGELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION
                    ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDECIMAL
                    ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEMONEY
                    ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: VALUETYPEISWRITTENASSTMT

        Private Sub ParseWHERESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: WHERESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHERESTMT), "WHERESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWHERE) ' Terminal Rule: KEYWDWHERE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWHERE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHERE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHERE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseCOMPARISON(node) ' NonTerminal Rule: COMPARISON
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND
                ParseADDITIONALCOMPARISON(node) ' NonTerminal Rule: ADDITIONALCOMPARISON
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WHERESTMT

        Private Sub ParseWHICHTHATCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: WHICHTHATCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHICHTHATCLAUSE), "WHICHTHATCLAUSE")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDIS
                    tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDIS

                             ' Concat Rule
                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDIS Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If

                             ' Concat Rule
                            tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.PREDICATE Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.PREDICATE
                            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREDICATE
                    tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.KEYWDIS

                             ' Concat Rule
                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.KEYWDIS Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If

                             ' Concat Rule
                            tok = m_scanner.Scan(TokenType.PREDICATE) ' Terminal Rule: PREDICATE
                            n = node.CreateNode(tok, tok.ToString() )
                            node.Token.UpdateRange(tok)
                            node.Nodes.Add(n)
                            If tok.Type <> TokenType.PREDICATE Then
                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                Return

                            End If

            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.PREDICATE
                            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDTHAT

                     ' Concat Rule
                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.KEYWDTHAT Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    tok = m_scanner.LookAhead(TokenType.PREDICATE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Choice Rule
                    Select Case tok.Type
                     ' Choice Rule
                        Case TokenType.PREDICATE
                            ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.PREBOUNDREADINGTEXT

                             ' Concat Rule
                            ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If

                             ' Concat Rule
                            tok = m_scanner.LookAhead(TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDISNOT
                                    tok = m_scanner.LookAhead(TokenType.KEYWDISNOT, TokenType.KEYWDIS) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.KEYWDISNOT
                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case TokenType.KEYWDIS
                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDIS Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDIS
                                    tok = m_scanner.LookAhead(TokenType.KEYWDISNOT, TokenType.KEYWDIS) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.KEYWDISNOT
                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case TokenType.KEYWDIS
                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDIS Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREDICATE
                                    ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case TokenType.MODELELEMENTNAME

                             ' Concat Rule
                            ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If

                             ' Concat Rule
                            tok = m_scanner.LookAhead(TokenType.KEYWDISNOT, TokenType.KEYWDIS, TokenType.PREDICATE) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDISNOT
                                    tok = m_scanner.LookAhead(TokenType.KEYWDISNOT, TokenType.KEYWDIS) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.KEYWDISNOT
                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case TokenType.KEYWDIS
                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDIS Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDIS
                                    tok = m_scanner.LookAhead(TokenType.KEYWDISNOT, TokenType.KEYWDIS) ' Choice Rule
                                    Select Case tok.Type
                                     ' Choice Rule
                                        Case TokenType.KEYWDISNOT
                                            tok = m_scanner.Scan(TokenType.KEYWDISNOT) ' Terminal Rule: KEYWDISNOT
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDISNOT Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case TokenType.KEYWDIS
                                            tok = m_scanner.Scan(TokenType.KEYWDIS) ' Terminal Rule: KEYWDIS
                                            n = node.CreateNode(tok, tok.ToString() )
                                            node.Token.UpdateRange(tok)
                                            node.Nodes.Add(n)
                                            If tok.Type <> TokenType.KEYWDIS Then
                                                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                                Return

                                            End If

            If m_tree.Errors.Count > 0 Then
                                                        parent.Token.UpdateRange(node.Token)
                                                        Exit Sub
            End If
                                        Case Else
                                        If m_tree.Errors.Count = 0 Then
                                        m_tree.Optionals.Clear
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                        End If
                                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                            Exit Select
                                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREDICATE
                                    ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDISNOT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDISNOT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Case Else
                        If m_tree.Errors.Count = 0 Then
                        m_tree.Optionals.Clear
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                        m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                        End If
                            m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                            Exit Select
                    End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREBOUNDREADINGTEXT

                     ' Concat Rule
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME

                     ' Concat Rule
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    ParsePREDICATECLAUSE(node) ' NonTerminal Rule: PREDICATECLAUSE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WHICHTHATCLAUSE

        Private Sub ParseWHICHCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: WHICHCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHICHCLAUSE), "WHICHCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH) ' Option Rule
            If tok.Type = TokenType.KEYWDAND Or tok.Type = TokenType.KEYWDWHICH Then
                tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH) ' Choice Rule
                Select Case tok.Type
                 ' Choice Rule
                    Case TokenType.KEYWDAND
                        tok = m_scanner.Scan(TokenType.KEYWDAND) ' Terminal Rule: KEYWDAND
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDAND Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDWHICH
                        tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDWHICH Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case Else
                    If m_tree.Errors.Count = 0 Then
                    m_tree.Optionals.Clear
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                    End If
                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                        Exit Select
                End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAND.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAND"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDWHICH, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
            If tok.Type = TokenType.KEYWDWITH Or tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Or tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.BROPEN Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                tok = m_scanner.LookAhead(TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDWHICH, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                Select Case tok.Type
                 ' Choice Rule
                    Case TokenType.KEYWDWITH
                        ParseWITHCLAUSE(node) ' NonTerminal Rule: WITHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDIS

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.PREDICATE

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDTHAT

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.PREBOUNDREADINGTEXT

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.MODELELEMENTNAME

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDWHICH

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDAN

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDA

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDCOUNT

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.NUMBER

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.SINGLEQUOTE

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.BROPEN

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.FOLLOWINGREADINGTEXT

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.MATHFUNCTION

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME) ' Option Rule
                        If tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Then
                            ParseWHICHTHATCLAUSE(node) ' NonTerminal Rule: WHICHTHATCLAUSE
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDIS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Option Rule
                        If tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Then
                            tok = m_scanner.LookAhead(TokenType.KEYWDWHICH, TokenType.KEYWDTHAT, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.KEYWDWHICH
                                    tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDWHICH Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDTHAT
                                    tok = m_scanner.Scan(TokenType.KEYWDTHAT) ' Terminal Rule: KEYWDTHAT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDTHAT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDTHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDAN
                                    tok = m_scanner.Scan(TokenType.KEYWDAN) ' Terminal Rule: KEYWDAN
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDAN Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDAN.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDA
                                    tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDA Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.KEYWDCOUNT
                                    tok = m_scanner.Scan(TokenType.KEYWDCOUNT) ' Terminal Rule: KEYWDCOUNT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.KEYWDCOUNT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDCOUNT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Option Rule
                        If tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.BROPEN Then
                            tok = m_scanner.LookAhead(TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.NUMBER
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.SINGLEQUOTE
                                    ParseINDIVIDUALIDENTIFIER(node) ' NonTerminal Rule: INDIVIDUALIDENTIFIER
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.PREBOUNDREADINGTEXT
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MODELELEMENTNAME
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.BROPEN
                                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If

                         ' Concat Rule
                        tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Option Rule
                        If tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION Then
                            tok = m_scanner.LookAhead(TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' Choice Rule
                            Select Case tok.Type
                             ' Choice Rule
                                Case TokenType.FOLLOWINGREADINGTEXT
                                    tok = m_scanner.Scan(TokenType.FOLLOWINGREADINGTEXT) ' Terminal Rule: FOLLOWINGREADINGTEXT
                                    n = node.CreateNode(tok, tok.ToString() )
                                    node.Token.UpdateRange(tok)
                                    node.Nodes.Add(n)
                                    If tok.Type <> TokenType.FOLLOWINGREADINGTEXT Then
                                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                        Return

                                    End If

            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case TokenType.MATHFUNCTION
                                    ParseMATHCLAUSE(node) ' NonTerminal Rule: MATHCLAUSE
            If m_tree.Errors.Count > 0 Then
                                                parent.Token.UpdateRange(node.Token)
                                                Exit Sub
            End If
                                Case Else
                                If m_tree.Errors.Count = 0 Then
                                m_tree.Optionals.Clear
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                                End If
                                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                                    Exit Select
                            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                                        parent.Token.UpdateRange(node.Token)
                                        Exit Sub
            End If
                        Else
                                                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOLLOWINGREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                        End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case Else
                    If m_tree.Errors.Count = 0 Then
                    m_tree.Optionals.Clear
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDIS"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREDICATE"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDTHAT"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCOUNT"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "NUMBER"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "SINGLEQUOTE"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "FOLLOWINGREADINGTEXT"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MATHFUNCTION"))
                    End If
                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                        Exit Select
                End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WHICHCLAUSE

        Private Sub ParseWITHCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: WITHCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WITHCLAUSE), "WITHCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWITH) ' Terminal Rule: KEYWDWITH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWITH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDWHAT, TokenType.KEYWDA) ' Option Rule
            If tok.Type = TokenType.KEYWDWHAT Or tok.Type = TokenType.KEYWDA Then
                tok = m_scanner.LookAhead(TokenType.KEYWDWHAT, TokenType.KEYWDA) ' Choice Rule
                Select Case tok.Type
                 ' Choice Rule
                    Case TokenType.KEYWDWHAT
                        tok = m_scanner.Scan(TokenType.KEYWDWHAT) ' Terminal Rule: KEYWDWHAT
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDWHAT Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHAT"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case TokenType.KEYWDA
                        tok = m_scanner.Scan(TokenType.KEYWDA) ' Terminal Rule: KEYWDA
                        n = node.CreateNode(tok, tok.ToString() )
                        node.Token.UpdateRange(tok)
                        node.Nodes.Add(n)
                        If tok.Type <> TokenType.KEYWDA Then
                            m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDA.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                            Return

                        End If

            If m_tree.Errors.Count > 0 Then
                                    parent.Token.UpdateRange(node.Token)
                                    Exit Sub
            End If
                    Case Else
                    If m_tree.Errors.Count = 0 Then
                    m_tree.Optionals.Clear
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHAT"))
                    m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                    End If
                        m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                        Exit Select
                End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            Else
                            m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHAT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHAT"))
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.PREBOUNDREADINGTEXT
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.BROPEN
                    ParseNODEPROPERTYIDENTIFICATION(node) ' NonTerminal Rule: NODEPROPERTYIDENTIFICATION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WITHCLAUSE

        Private Sub ParseWHICHSELECTSTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: WHICHSELECTSTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WHICHSELECTSTMT), "WHICHSELECTSTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWHICH) ' Terminal Rule: KEYWDWHICH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWHICH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWHICH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.BROPEN) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.PREBOUNDREADINGTEXT
                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.BROPEN
                    ParseNODE(node) ' NonTerminal Rule: NODE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.PREBOUNDREADINGTEXT
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.MODELELEMENTNAME
                    ParseMODELELEMENT(node) ' NonTerminal Rule: MODELELEMENT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "BROPEN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "PREBOUNDREADINGTEXT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PREBOUNDREADINGTEXT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "MODELELEMENTNAME"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
            While tok.Type = TokenType.KEYWDAND Or tok.Type = TokenType.KEYWDWHICH Or tok.Type = TokenType.KEYWDWITH Or tok.Type = TokenType.KEYWDIS Or tok.Type = TokenType.PREDICATE Or tok.Type = TokenType.KEYWDTHAT Or tok.Type = TokenType.PREBOUNDREADINGTEXT Or tok.Type = TokenType.MODELELEMENTNAME Or tok.Type = TokenType.KEYWDAN Or tok.Type = TokenType.KEYWDA Or tok.Type = TokenType.KEYWDCOUNT Or tok.Type = TokenType.NUMBER Or tok.Type = TokenType.SINGLEQUOTE Or tok.Type = TokenType.BROPEN Or tok.Type = TokenType.FOLLOWINGREADINGTEXT Or tok.Type = TokenType.MATHFUNCTION
                ParseWHICHCLAUSE(node) ' NonTerminal Rule: WHICHCLAUSE
            If m_tree.Errors.Count > 0 Then
                            parent.Token.UpdateRange(node.Token)
                            Exit Sub
            End If
            tok = m_scanner.LookAhead(TokenType.KEYWDAND, TokenType.KEYWDWHICH, TokenType.KEYWDWITH, TokenType.KEYWDIS, TokenType.PREDICATE, TokenType.KEYWDTHAT, TokenType.PREBOUNDREADINGTEXT, TokenType.MODELELEMENTNAME, TokenType.KEYWDAN, TokenType.KEYWDA, TokenType.KEYWDCOUNT, TokenType.NUMBER, TokenType.SINGLEQUOTE, TokenType.BROPEN, TokenType.FOLLOWINGREADINGTEXT, TokenType.MATHFUNCTION) ' ZeroOrMore Rule
            End While
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.EOF Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WHICHSELECTSTMT

        Private Sub ParseWITHPREDICATESTMT(ByVal parent As ParseNode) ' NonTerminalSymbol: WITHPREDICATESTMT
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WITHPREDICATESTMT), "WITHPREDICATESTMT")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWITH) ' Terminal Rule: KEYWDWITH
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWITH Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWITH.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWITH"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDPREDICATE) ' Terminal Rule: KEYWDPREDICATE
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDPREDICATE Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDPREDICATE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDPREDICATE"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseBRACKTEDCOLMNLIST(node) ' NonTerminal Rule: BRACKTEDCOLMNLIST
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            ParseVALUELIST(node) ' NonTerminal Rule: VALUELIST
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WITHPREDICATESTMT

        Private Sub ParseWRITTENASCLAUSE(ByVal parent As ParseNode) ' NonTerminalSymbol: WRITTENASCLAUSE
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.WRITTENASCLAUSE), "WRITTENASCLAUSE")
            parent.Nodes.Add(node)


             ' Concat Rule
            tok = m_scanner.Scan(TokenType.KEYWDWRITTENAS) ' Terminal Rule: KEYWDWRITTENAS
            n = node.CreateNode(tok, tok.ToString() )
            node.Token.UpdateRange(tok)
            node.Nodes.Add(n)
            If tok.Type <> TokenType.KEYWDWRITTENAS Then
                m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDWRITTENAS.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWRITTENAS"))
                Return

            End If

            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

             ' Concat Rule
            tok = m_scanner.LookAhead(TokenType.KEYWDDATATYPELOGICALTRUEFALSE, TokenType.KEYWDDATATYPELOGICALYESNO, TokenType.KEYWDDATATYPEAUTOCOUNTER, TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION, TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION, TokenType.KEYWDDATATYPESIGNEDBIGINTEGER, TokenType.KEYWDDATATYPESIGNEDINTEGER, TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER, TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER, TokenType.KEYWDDATATYPEOBJECTID, TokenType.KEYWDDATATYPEROWID, TokenType.KEYWDDATATYPERAWDATAOLEOBJECT, TokenType.KEYWDDATATYPERAWDATA, TokenType.KEYWDDATATYPEAUTOTIMESTAMP, TokenType.KEYWDDATATYPEDATE, TokenType.KEYWDDATATYPEDATETIME, TokenType.KEYWDDATATYPETIME, TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH, TokenType.KEYWDDATATYPERAWDATALARGELENGTH, TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH, TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH, TokenType.KEYWDDATATYPESTRINGLARGELENGTH, TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH, TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION, TokenType.KEYWDDATATYPEDECIMAL, TokenType.KEYWDDATATYPEMONEY) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDDATATYPELOGICALTRUEFALSE
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPELOGICALYESNO
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEAUTOCOUNTER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATDOUBLEPRECISION
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATSINGLEPRECISION
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDBIGINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESIGNEDSMALLINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDBIGINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDSMALLINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEUNSIGNEDTINYINTEGER
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEOBJECTID
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEROWID
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAOLEOBJECT
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATA
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEAUTOTIMESTAMP
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDATE
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDATETIME
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPETIME
                    ParseDATATYPE(node) ' NonTerminal Rule: DATATYPE
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAFIXEDLENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATALARGELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPERAWDATAVARIABLELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGFIXEDLENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGLARGELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPESTRINGVARIABLELENGTH
                    ParseDATATYPELENGTH(node) ' NonTerminal Rule: DATATYPELENGTH
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEFLOATCUSTOMPRECISION
                    ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEDECIMAL
                    ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDATATYPEMONEY
                    ParseDATATYPEPRECISION(node) ' NonTerminal Rule: DATATYPEPRECISION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALTRUEFALSE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPELOGICALYESNO"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOCOUNTER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATDOUBLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATSINGLEPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDBIGINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDSMALLINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEUNSIGNEDTINYINTEGER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEOBJECTID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEROWID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAOLEOBJECT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEAUTOTIMESTAMP"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDATETIME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPETIME"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAFIXEDLENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATALARGELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPERAWDATAVARIABLELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGFIXEDLENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGLARGELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPESTRINGVARIABLELENGTH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEFLOATCUSTOMPRECISION"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEDECIMAL"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDDATATYPELOGICALTRUEFALSE.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDATATYPEMONEY"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: WRITTENASCLAUSE

        Private Sub ParseStart(ByVal parent As ParseNode) ' NonTerminalSymbol: Start
            Dim tok As Token
            Dim n As ParseNode
            Dim node As ParseNode = parent.CreateNode(m_scanner.GetToken(TokenType.Start), "Start")
            parent.Nodes.Add(node)

            tok = m_scanner.LookAhead(TokenType.KEYWDADDFACT, TokenType.KEYWDASSERT, TokenType.KEYWDCREATE, TokenType.KEYWDDELETE, TokenType.KEYWDDELETEALL, TokenType.KEYWDDELETEFACT, TokenType.KEYWDDESCRIBE, TokenType.KEYWDDID, TokenType.KEYWDSHOW, TokenType.KEYWDEACH, TokenType.KEYWDEITHER, TokenType.KEYWDA, TokenType.KEYWDAN, TokenType.KEYWDENUMERATE, TokenType.KEYWDMATCH, TokenType.KEYWDWHICH, TokenType.KEYWDNULL) ' Choice Rule
            Select Case tok.Type
             ' Choice Rule
                Case TokenType.KEYWDADDFACT
                    ParseADDFACTSTMT(node) ' NonTerminal Rule: ADDFACTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDASSERT
                    ParseASSERTSTMT(node) ' NonTerminal Rule: ASSERTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDCREATE
                    ParseCREATESTMT(node) ' NonTerminal Rule: CREATESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDELETE
                    ParseDELETESTMT(node) ' NonTerminal Rule: DELETESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDELETEALL
                    ParseDELETEALLSTMT(node) ' NonTerminal Rule: DELETEALLSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDELETEFACT
                    ParseDELETEFACTSTMT(node) ' NonTerminal Rule: DELETEFACTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDESCRIBE
                    ParseDESCRIBESTMT(node) ' NonTerminal Rule: DESCRIBESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDDID
                    ParseDIDSELECTSTMT(node) ' NonTerminal Rule: DIDSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDSHOW
                    ParseSHOWSTMT(node) ' NonTerminal Rule: SHOWSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDEACH
                    ParseCONSTRAINTEXTERNALSTMT(node) ' NonTerminal Rule: CONSTRAINTEXTERNALSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDEITHER
                    ParseCONSTRAINTEITHEROR(node) ' NonTerminal Rule: CONSTRAINTEITHEROR
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDA
                    ParseDERIVEDFACTTYPESTMT(node) ' NonTerminal Rule: DERIVEDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDAN
                    ParseDERIVEDFACTTYPESTMT(node) ' NonTerminal Rule: DERIVEDFACTTYPESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDENUMERATE
                    ParseENUMERATESTMT(node) ' NonTerminal Rule: ENUMERATESTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDMATCH
                    ParseMATCHSELECTSTMT(node) ' NonTerminal Rule: MATCHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDWHICH
                    ParseWHICHSELECTSTMT(node) ' NonTerminal Rule: WHICHSELECTSTMT
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case TokenType.KEYWDNULL

                     ' Concat Rule
                    ParseFACTTYPEPRODUCTION(node) ' NonTerminal Rule: FACTTYPEPRODUCTION
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If

                     ' Concat Rule
                    tok = m_scanner.Scan(TokenType.EOF) ' Terminal Rule: EOF
                    n = node.CreateNode(tok, tok.ToString() )
                    node.Token.UpdateRange(tok)
                    node.Nodes.Add(n)
                    If tok.Type <> TokenType.EOF Then
                        m_tree.Errors.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "EOF"))
                        Return

                    End If

            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
            If m_tree.Errors.Count > 0 Then
                                parent.Token.UpdateRange(node.Token)
                                Exit Sub
            End If
                Case Else
                If m_tree.Errors.Count = 0 Then
                m_tree.Optionals.Clear
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDADDFACT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDASSERT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDCREATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEALL"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDELETEFACT"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDESCRIBE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDDID"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDSHOW"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEACH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDEITHER"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDA"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDAN"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDENUMERATE"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDMATCH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDWHICH"))
                m_tree.Optionals.Add(New ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.KEYWDADDFACT.ToString(), &H1001, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos, "KEYWDNULL"))
                End If
                    m_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", &H0002, 0, tok.StartPos, tok.StartPos, tok.EndPos - tok.StartPos))
                    Exit Select
            End Select ' Choice Rule
            If m_tree.Errors.Count > 0 Then
                        parent.Token.UpdateRange(node.Token)
                        Exit Sub
            End If

            parent.Token.UpdateRange(node.Token)
            If m_scanner.Input.Length > (parent.Token.EndPos + 1) Then
            m_tree.Optionals.Clear()
            End If
        End Sub ' NonTerminalSymbol: Start


    End Class
#End Region
End Namespace

